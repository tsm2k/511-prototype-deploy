"use client"

import { useEffect, useRef, useState } from "react"
import mapboxgl from "mapbox-gl"
import "mapbox-gl/dist/mapbox-gl.css"
import MapboxDraw from "@mapbox/mapbox-gl-draw"
import "@mapbox/mapbox-gl-draw/dist/mapbox-gl-draw.css"
import { Button } from "@/components/ui/button"
import { Card } from "@/components/ui/card"
import { Checkbox } from "@/components/ui/checkbox"
import { Label } from "@/components/ui/label"
import { ChevronUp, ChevronDown, Info, AlertTriangle, Construction, Clock, Map as MapIcon } from "lucide-react"
import { DataSourceMetadata, fetchDataSourcesMetadata } from "@/services/api"
import { PointOfInterest } from "@/services/poi-service"
import * as turf from '@turf/turf'

mapboxgl.accessToken = "pk.eyJ1IjoidGFuYXkyayIsImEiOiJjbTJpYnltejYwbDgwMmpvbm1lNG16enV3In0.fwcdZ3I-cofnDOR9m1Hqng"

// Unique source and layer IDs for roads, POI circles, and boundaries
let roadSourceCounter = 0;
let poiCircleCounter = 0;
let boundarySourceCounter = 0;

// Constants for marker clustering
const CLUSTER_SOURCE_ID = 'markers-cluster-source';
const CLUSTER_LAYER_ID = 'markers-cluster-layer';
const CLUSTER_COUNT_LAYER_ID = 'markers-cluster-count-layer';
const UNCLUSTERED_POINT_LAYER_ID = 'markers-unclustered-point-layer';

// Define interface for map data
interface MapData {
  id: number;
  datasource_metadata_id: number;
  datasource_tablename: string;
  event_type?: string;
  priority_level?: number;
  event_status?: string;
  route?: string;
  start_mile_marker?: number;
  end_mile_marker?: number;
  readable_coordinates: string;
  [key: string]: any; // Allow for additional properties
}

// Helper function to calculate bounding box from polygon coordinates
const getBoundingBox = (coordinates: number[][]) => {
  if (!coordinates || coordinates.length === 0) return null;
  
  // Initialize with the first point
  let minX = coordinates[0][0];
  let maxX = coordinates[0][0];
  let minY = coordinates[0][1];
  let maxY = coordinates[0][1];
  
  // Find min/max for all points
  coordinates.forEach(point => {
    minX = Math.min(minX, point[0]);
    maxX = Math.max(maxX, point[0]);
    minY = Math.min(minY, point[1]);
    maxY = Math.max(maxY, point[1]);
  });
  
  return {
    southwest: [minX, minY],
    northeast: [maxX, maxY]
  };
};

export function MapView({ queryResults }: { queryResults?: any }) {
  // Function to clear all markers - defined early to avoid reference errors
  const clearMarkers = () => {
    // Clear any traditional markers (for backward compatibility)
    if (markersRef.current) {
      markersRef.current.forEach(marker => marker.remove());
      markersRef.current = [];
    }
    
    if (popupsRef.current) {
      popupsRef.current.forEach(popup => popup.remove());
      popupsRef.current = [];
    }
    
    // Clear the clustered markers by resetting the GeoJSON source
    if (map.current) {
      const source = map.current.getSource(CLUSTER_SOURCE_ID) as mapboxgl.GeoJSONSource;
      if (source) {
        source.setData({
          type: 'FeatureCollection',
          features: []
        });
      }
    }
  };
  
  // Function to clear only POI markers and circles
  const clearPOIMarkers = () => {
    if (poiMarkersRef.current) {
      poiMarkersRef.current.forEach(marker => marker.remove());
      poiMarkersRef.current = [];
    }
    
    // Also clear POI circle layers
    if (map.current && poiCircleLayersRef.current.length > 0) {
      poiCircleLayersRef.current.forEach(({sourceId, layerId}) => {
        if (map.current?.getLayer(layerId)) {
          map.current.removeLayer(layerId);
        }
        if (map.current?.getSource(sourceId)) {
          map.current.removeSource(sourceId);
        }
      });
      poiCircleLayersRef.current = [];
    }
  };
  
  // Function to clear road layers
  const clearRoadLayers = () => {
    if (map.current) {
      roadLayersRef.current.forEach(({sourceId, layerId}) => {
        if (map.current?.getLayer(layerId)) {
          map.current.removeLayer(layerId);
        }
        if (map.current?.getSource(sourceId)) {
          map.current.removeSource(sourceId);
        }
      });
      roadLayersRef.current = [];
    }
  };
  
  // Function to clear boundary layers
  const clearBoundaryLayers = () => {
    if (map.current) {
      boundaryLayersRef.current.forEach(({sourceId, layerId}) => {
        if (map.current?.getLayer(layerId)) {
          map.current.removeLayer(layerId);
        }
        if (map.current?.getSource(sourceId)) {
          map.current.removeSource(sourceId);
        }
      });
      boundaryLayersRef.current = [];
    }
  };
  
  // Function to clear all preview layers
  const clearAllPreviews = () => {
    clearPreviewRoadLayers();
    clearPreviewPoiLayers();
    clearPreviewBoundaryLayers();
  };
  
  // Function to clear preview road layers
  const clearPreviewRoadLayers = () => {
    if (map.current) {
      previewRoadLayersRef.current.forEach(({sourceId, layerId}) => {
        if (map.current?.getLayer(layerId)) {
          map.current.removeLayer(layerId);
        }
        if (map.current?.getSource(sourceId)) {
          map.current.removeSource(sourceId);
        }
      });
      previewRoadLayersRef.current = [];
    }
  };
  
  // Function to clear preview POI layers
  const clearPreviewPoiLayers = () => {
    if (map.current) {
      previewPoiLayersRef.current.forEach(({sourceId, layerId}) => {
        if (map.current?.getLayer(layerId)) {
          map.current.removeLayer(layerId);
        }
        if (map.current?.getSource(sourceId)) {
          map.current.removeSource(sourceId);
        }
      });
      previewPoiLayersRef.current = [];
    }
  };
  
  // Function to clear preview boundary layers
  const clearPreviewBoundaryLayers = () => {
    if (map.current) {
      previewBoundaryLayersRef.current.forEach(({sourceId, layerId}) => {
        if (map.current?.getLayer(layerId)) {
          map.current.removeLayer(layerId);
        }
        if (map.current?.getSource(sourceId)) {
          map.current.removeSource(sourceId);
        }
      });
      previewBoundaryLayersRef.current = [];
    }
  };
  
  // Function to clear specific boundary by name and type
  const clearBoundaryByNameAndType = (name: string, type: string) => {
    if (map.current) {
      const boundariesToRemove = boundaryLayersRef.current.filter(
        boundary => boundary.name === name && boundary.type === type
      );
      
      boundariesToRemove.forEach(({sourceId, layerId}) => {
        if (map.current?.getLayer(layerId)) {
          map.current.removeLayer(layerId);
        }
        if (map.current?.getSource(sourceId)) {
          map.current.removeSource(sourceId);
        }
      });
      
      // Update the ref to exclude the removed boundaries
      boundaryLayersRef.current = boundaryLayersRef.current.filter(
        boundary => !(boundary.name === name && boundary.type === type)
      );
    }
  };
  
  // Function to clear specific preview boundary by name and type
  const clearPreviewBoundaryByNameAndType = (name: string, type: string) => {
    if (map.current) {
      const boundariesToRemove = previewBoundaryLayersRef.current.filter(
        boundary => boundary.name === name && boundary.type === type
      );
      
      boundariesToRemove.forEach(({sourceId, layerId}) => {
        if (map.current?.getLayer(layerId)) {
          map.current.removeLayer(layerId);
        }
        if (map.current?.getSource(sourceId)) {
          map.current.removeSource(sourceId);
        }
      });
      
      // Update the ref to exclude the removed boundaries
      previewBoundaryLayersRef.current = previewBoundaryLayersRef.current.filter(
        boundary => !(boundary.name === name && boundary.type === type)
      );
    }
  };
  
  // Function to clear specific preview road by name
  const clearPreviewRoadByName = (name: string) => {
    if (map.current) {
      const roadsToRemove = previewRoadLayersRef.current.filter(
        road => road.name === name
      );
      
      roadsToRemove.forEach(({sourceId, layerId}) => {
        if (map.current?.getLayer(layerId)) {
          map.current.removeLayer(layerId);
        }
        if (map.current?.getSource(sourceId)) {
          map.current.removeSource(sourceId);
        }
      });
      
      // Update the ref to exclude the removed roads
      previewRoadLayersRef.current = previewRoadLayersRef.current.filter(
        road => road.name !== name
      );
    }
  };
  
  // Function to clear specific preview POI by name
  const clearPreviewPoiByName = (name: string) => {
    if (map.current) {
      // Remove layer and source
      const poisToRemove = previewPoiLayersRef.current.filter(
        poi => poi.name === name
      );
      
      poisToRemove.forEach(({sourceId, layerId}) => {
        if (map.current?.getLayer(layerId)) {
          map.current.removeLayer(layerId);
        }
        if (map.current?.getSource(sourceId)) {
          map.current.removeSource(sourceId);
        }
      });
      
      // Update the ref to exclude the removed POIs
      previewPoiLayersRef.current = previewPoiLayersRef.current.filter(
        poi => poi.name !== name
      );
      
      // Also remove any markers for this POI
      if (poiMarkersRef.current && poiMarkersRef.current.length > 0) {
        // Since we don't have a direct way to identify which marker belongs to which POI,
        // we'll remove all markers when clearing previews
        poiMarkersRef.current.forEach(marker => marker.remove());
        poiMarkersRef.current = [];
      }
    }
  };
  
  const mapContainer = useRef<HTMLDivElement>(null)
  const map = useRef<mapboxgl.Map | null>(null)
  const drawRef = useRef<MapboxDraw | null>(null)
  const markersRef = useRef<mapboxgl.Marker[]>([])
  const poiMarkersRef = useRef<mapboxgl.Marker[]>([]) // Separate ref for POI markers
  const popupsRef = useRef<mapboxgl.Popup[]>([])
  const roadLayersRef = useRef<{sourceId: string, layerId: string}[]>([]) // Track road layers
  const poiCircleLayersRef = useRef<{sourceId: string, layerId: string, poiName: string}[]>([]) // Track POI circle layers
  const boundaryLayersRef = useRef<{sourceId: string, layerId: string, name: string, type: string}[]>([]) // Track boundary layers
  
  // Refs for preview layers
  const previewRoadLayersRef = useRef<{sourceId: string, layerId: string, name: string}[]>([]) // Track road preview layers
  const previewPoiLayersRef = useRef<{sourceId: string, layerId: string, name: string}[]>([]) // Track POI preview layers
  const previewBoundaryLayersRef = useRef<{sourceId: string, layerId: string, name: string, type: string}[]>([]) // Track boundary preview layers
  const resizeObserverRef = useRef<ResizeObserver | null>(null)
  
  // State for dataset metadata (for display names and colors)
  const [datasetMetadata, setDatasetMetadata] = useState<Record<string, DataSourceMetadata>>({})
  const [visibleLayers, setVisibleLayers] = useState<Record<string, boolean>>({})
  const [showLegend, setShowLegend] = useState(true)
  const [drawModeActive, setDrawModeActive] = useState(false)

  // Fetch dataset metadata for display names and colors
  useEffect(() => {
    const fetchMetadata = async () => {
      try {
        const datasources = await fetchDataSourcesMetadata();
        const metadataMap = datasources.reduce((acc, source) => {
          acc[source.datasource_tablename] = source;
          return acc;
        }, {} as Record<string, DataSourceMetadata>);
        setDatasetMetadata(metadataMap);
        
        // Initialize all layers as visible
        const initialVisibility = datasources.reduce((acc, source) => {
          acc[source.datasource_tablename] = true;
          return acc;
        }, {} as Record<string, boolean>);
        setVisibleLayers(initialVisibility);
      } catch (error) {
        console.error('Error fetching dataset metadata:', error);
      }
    };

    fetchMetadata();
  }, []);

  // Listen for POI selection events from LocationSelector
  useEffect(() => {
    const handlePOISelection = (event: CustomEvent) => {
      console.log('POI selection event received:', event.detail);
      if (map.current) {
        const { name, coordinates, type, radius } = event.detail;
        
        // Add marker for the POI
        addPOIMarkerToMap(name, coordinates, radius);
      }
    };
    
    // Add event listener for POI selection events
    window.addEventListener('poi-selection-added', handlePOISelection as EventListener);
    
    return () => {
      // Clean up event listener
      window.removeEventListener('poi-selection-added', handlePOISelection as EventListener);
    };
  }, []);
  
  // Listen for POI preview events
  useEffect(() => {
    // Handler for showing POI preview
    const handlePOIPreviewShow = (event: CustomEvent) => {
      console.log('POI preview show event received:', event.detail);
      if (map.current) {
        const { name, coordinates, radius } = event.detail;
        
        // Clear any existing preview for this POI
        clearPreviewPoiByName(name);
        
        // Create unique source and layer IDs for the preview
        const sourceId = `preview-poi-source-${poiCircleCounter}`;
        const layerId = `preview-poi-layer-${poiCircleCounter}`;
        poiCircleCounter++;
        
        // Always add a marker at the POI location regardless of radius
        const markerElement = document.createElement('div');
        markerElement.className = 'poi-marker';
        markerElement.style.width = '15px';
        markerElement.style.height = '15px';
        markerElement.style.borderRadius = '50%';
        markerElement.style.backgroundColor = '#3b82f6';
        markerElement.style.border = '2px solid white';
        markerElement.style.boxShadow = '0 0 0 2px rgba(0, 0, 0, 0.1)';
        // Add data attribute to identify the POI for removal
        markerElement.setAttribute('data-poi-name', name);
        markerElement.setAttribute('data-poi-type', 'preview'); // Mark as preview marker
        
        // Create a popup with the POI name
        const popup = new mapboxgl.Popup({ offset: 25 })
          .setText(`${name} (Preview)`);
        
        // Create and add the marker
        const marker = new mapboxgl.Marker(markerElement)
          .setLngLat([coordinates.lng, coordinates.lat])
          .setPopup(popup)
          .addTo(map.current);
        
        // Store the marker reference for later removal
        if (!poiMarkersRef.current) {
          poiMarkersRef.current = [];
        }
        poiMarkersRef.current.push(marker);
        
        // Add circle if radius is specified and greater than 0
        if (radius && radius > 0) {
          // Create a point using Turf.js
          const point = turf.point([coordinates.lng, coordinates.lat]);
          
          // Create a circle with the specified radius in miles
          // Note: turf.buffer takes radius in kilometers, so convert miles to km
          const radiusKm = radius * 1.60934;
          const circle = turf.buffer(point, radiusKm, { units: 'kilometers' });
          
          // Add the circle as a source
          map.current.addSource(sourceId, {
            type: 'geojson',
            data: circle
          });
          
          // Add a fill layer for the circle
          map.current.addLayer({
            id: layerId,
            type: 'fill',
            source: sourceId,
            paint: {
              'fill-color': '#3b82f6', // Blue color for preview
              'fill-opacity': 0.3,
              'fill-outline-color': '#3b82f6'
            }
          });
          
          // Store the layer references for later removal
          previewPoiLayersRef.current.push({ sourceId, layerId, name });
        }
        
        // Always fly to the POI location regardless of radius
        map.current.flyTo({
          center: [coordinates.lng, coordinates.lat],
          zoom: 12
        });
      }
    };
    
    // Handler for hiding POI preview
    const handlePOIPreviewHide = (event: CustomEvent) => {
      console.log('POI preview hide event received:', event.detail);
      if (map.current) {
        const { name } = event.detail;
        clearPreviewPoiByName(name);
      }
    };
    
    // Handler for updating POI preview (e.g., when radius changes)
    const handlePOIPreviewUpdate = (event: CustomEvent) => {
      console.log('POI preview update event received:', event.detail);
      if (map.current) {
        const { name, coordinates, radius } = event.detail;
        
        // Remove the existing preview and create a new one with the updated radius
        clearPreviewPoiByName(name);
        
        // Create unique source and layer IDs for the preview
        const sourceId = `preview-poi-source-${poiCircleCounter}`;
        const layerId = `preview-poi-layer-${poiCircleCounter}`;
        poiCircleCounter++;
        
        // Add a circle for the POI with a different style to indicate it's a preview
        if (coordinates) {
          // Convert radius from miles to meters
          const radiusInMeters = radius * 1609.34;
          
          // Create a circle using turf.js
          const point = turf.point([coordinates.lng, coordinates.lat]);
          const circle = turf.circle(point, radiusInMeters, { steps: 64, units: 'meters' });
          
          // Add source and layer to map
          map.current.addSource(sourceId, {
            type: 'geojson',
            data: circle
          });
          
          // Add fill layer with a semi-transparent fill
          map.current.addLayer({
            id: layerId,
            type: 'fill',
            source: sourceId,
            paint: {
              'fill-color': '#3b82f6', // Blue color for preview
              'fill-opacity': 0.3,
              'fill-outline-color': '#3b82f6'
            }
          });
          
          // Store the layer references for later removal
          previewPoiLayersRef.current.push({ sourceId, layerId, name });
        }
      }
    };
    
    // Add event listeners
    window.addEventListener('poi-preview-show', handlePOIPreviewShow as EventListener);
    window.addEventListener('poi-preview-hide', handlePOIPreviewHide as EventListener);
    window.addEventListener('poi-preview-update', handlePOIPreviewUpdate as EventListener);
    
    return () => {
      // Clean up event listeners
      window.removeEventListener('poi-preview-show', handlePOIPreviewShow as EventListener);
      window.removeEventListener('poi-preview-hide', handlePOIPreviewHide as EventListener);
      window.removeEventListener('poi-preview-update', handlePOIPreviewUpdate as EventListener);
    };
  }, []);
  
  // Listen for Road selection events from LocationSelector
  useEffect(() => {
    const handleRoadSelection = (event: CustomEvent) => {
      console.log('Road selection event received:', event.detail);
      if (map.current) {
        const { name, coordinates, type } = event.detail;
        
        // Add road line to map
        addRoadToMap(name, coordinates);
      }
    };
    
    // Add event listener for Road selection events
    window.addEventListener('road-selection-added', handleRoadSelection as EventListener);
    
    return () => {
      // Clean up event listener
      window.removeEventListener('road-selection-added', handleRoadSelection as EventListener);
    };
  }, []);
  
  // Listen for Road preview events
  useEffect(() => {
    // Handler for showing road preview
    const handleRoadPreviewShow = (event: CustomEvent) => {
      console.log('Road preview show event received:', event.detail);
      if (map.current) {
        const { road } = event.detail;
        const { name, coordinates } = road;
        
        console.log(`Road preview coordinates for ${name}:`, coordinates);
        
        // Clear any existing preview for this road
        clearPreviewRoadByName(name);
        
        if (coordinates && coordinates.length > 0) {
          // Create unique source and layer IDs for the preview
          const sourceId = `preview-road-source-${roadSourceCounter}`;
          const layerId = `preview-road-layer-${roadSourceCounter}`;
          roadSourceCounter++;
          
          console.log(`Raw road coordinates type for ${name}:`, Array.isArray(coordinates) ? 'Array' : typeof coordinates);
          
          // Handle MultiLineString format from road-service.ts
          // The coordinates from getRoadCoordinates are in format number[][][] (MultiLineString)
          if (Array.isArray(coordinates) && coordinates.length > 0 && Array.isArray(coordinates[0])) {
            // Create a bounds object to encompass all line segments
            const bounds = new mapboxgl.LngLatBounds();
            
            // Process each line segment in the MultiLineString
            coordinates.forEach((lineSegment: number[][]) => {
              if (Array.isArray(lineSegment) && lineSegment.length > 0) {
                // Extend bounds with each coordinate in this line segment
                lineSegment.forEach((coord: number[]) => {
                  if (Array.isArray(coord) && coord.length >= 2) {
                    bounds.extend([coord[0], coord[1]]);
                  }
                });
              }
            });
            
            // Create a GeoJSON feature for the road with MultiLineString geometry
            const roadFeature: GeoJSON.Feature<GeoJSON.MultiLineString> = {
              type: 'Feature',
              properties: {},
              geometry: {
                type: 'MultiLineString',
                coordinates: coordinates
              }
            };
            
            console.log(`Created MultiLineString feature for ${name}:`, roadFeature);
            
            // Add source and layer to map
            map.current.addSource(sourceId, {
              type: 'geojson',
              data: roadFeature
            });
            
            // Add line layer with a different style to indicate it's a preview
            map.current.addLayer({
              id: layerId,
              type: 'line',
              source: sourceId,
              paint: {
                'line-color': '#3b82f6', // Blue color for preview
                'line-width': 6,         // Thicker line for better visibility
                'line-opacity': 0.9,     // More opaque
                'line-dasharray': [2, 1] // Dashed line to distinguish from regular selections
              }
            });
            
            // Store the layer references for later removal
            previewRoadLayersRef.current.push({ sourceId, layerId, name });
            
            // Fit the map to the road
            map.current.fitBounds(bounds, {
              padding: 50
            });
            
            return; // Exit early since we've handled the MultiLineString case
          }
          
          // Fallback for other coordinate formats
          // This handles the case where coordinates might be in a different format
          const validCoordinates = Array.isArray(coordinates) ? 
            coordinates.flatMap((coord: any) => {
              if (Array.isArray(coord) && coord.length >= 2) {
                return [[coord[0], coord[1]]]; // Already in [lng, lat] format
              } else if (coord.lng !== undefined && coord.lat !== undefined) {
                return [[coord.lng, coord.lat]]; // Convert {lng, lat} to [lng, lat]
              } else if (coord.longitude !== undefined && coord.latitude !== undefined) {
                return [[coord.longitude, coord.latitude]]; // Convert {longitude, latitude} to [lng, lat]
              } else {
                console.error('Invalid coordinate format:', coord);
                return [];
              }
            }) : [];
          
          console.log(`Processed road coordinates for ${name}:`, validCoordinates);
          
          if (validCoordinates.length < 2) {
            console.error(`Not enough valid coordinates for road ${name}`);
            return;
          }
          
          // Create a GeoJSON feature for the road with LineString geometry
          const roadFeature: GeoJSON.Feature<GeoJSON.LineString> = {
            type: 'Feature',
            properties: {},
            geometry: {
              type: 'LineString',
              coordinates: validCoordinates
            }
          };
          
          console.log(`Created LineString feature for ${name}:`, roadFeature);
          
          // Add source and layer to map
          map.current.addSource(sourceId, {
            type: 'geojson',
            data: roadFeature
          });
          
          // Add line layer with a different style to indicate it's a preview
          map.current.addLayer({
            id: layerId,
            type: 'line',
            source: sourceId,
            paint: {
              'line-color': '#3b82f6', // Blue color for preview
              'line-width': 6,         // Thicker line for better visibility
              'line-opacity': 0.9,     // More opaque
              'line-dasharray': [2, 1] // Dashed line to distinguish from regular selections
            }
          });
          
          // Store the layer references for later removal
          previewRoadLayersRef.current.push({ sourceId, layerId, name });
          
          // Fit the map to the road
          const bounds = new mapboxgl.LngLatBounds();
          validCoordinates.forEach((coord: number[]) => {
            bounds.extend([coord[0], coord[1]]);
          });
          
          map.current.fitBounds(bounds, {
            padding: 50
          });
        }
      }
    };
    
    // Handler for hiding road preview
    const handleRoadPreviewHide = (event: CustomEvent) => {
      console.log('Road preview hide event received:', event.detail);
      if (map.current) {
        const { road } = event.detail;
        clearPreviewRoadByName(road.name);
      }
    };
    
    // Add event listeners
    window.addEventListener('road-preview-show', handleRoadPreviewShow as EventListener);
    window.addEventListener('road-preview-hide', handleRoadPreviewHide as EventListener);
    
    return () => {
      // Clean up event listeners
      window.removeEventListener('road-preview-show', handleRoadPreviewShow as EventListener);
      window.removeEventListener('road-preview-hide', handleRoadPreviewHide as EventListener);
    };
  }, []);
  
  // Listen for City preview events
  useEffect(() => {
    // Handler for showing city preview
    const handleCityPreviewShow = (event: CustomEvent) => {
      console.log('City preview show event received:', event.detail);
      if (map.current) {
        const { name, feature } = event.detail;
        
        // Clear any existing preview for this city
        clearPreviewBoundaryByNameAndType(name, 'city');
        
        // Create unique source and layer IDs for the preview
        const sourceId = `preview-city-source-${boundarySourceCounter}`;
        const layerId = `preview-city-layer-${boundarySourceCounter}`;
        boundarySourceCounter++;
        
        // Add source and layer to map
        map.current.addSource(sourceId, {
          type: 'geojson',
          data: feature
        });
        
        // Add fill layer with a different style to indicate it's a preview
        map.current.addLayer({
          id: layerId,
          type: 'fill',
          source: sourceId,
          paint: {
            'fill-color': '#10b981', // Green color for cities
            'fill-opacity': 0.3,
            'fill-outline-color': '#10b981'
          }
        });
        
        // Store the layer references for later removal
        previewBoundaryLayersRef.current.push({ sourceId, layerId, name, type: 'city' });
        
        // Fit the map to the boundary
        const bounds = new mapboxgl.LngLatBounds();
        
        // Handle both Polygon and MultiPolygon geometries
        if (feature.geometry.type === 'Polygon') {
          feature.geometry.coordinates[0].forEach((coord: number[]) => {
            bounds.extend([coord[0], coord[1]]);
          });
        } else if (feature.geometry.type === 'MultiPolygon') {
          feature.geometry.coordinates.forEach((polygon: number[][][]) => {
            polygon[0].forEach((coord: number[]) => {
              bounds.extend([coord[0], coord[1]]);
            });
          });
        }
        
        // Fly to the boundary with padding
        map.current.fitBounds(bounds, {
          padding: 50
        });
      }
    };
    
    // Handler for hiding city preview
    const handleCityPreviewHide = (event: CustomEvent) => {
      console.log('City preview hide event received:', event.detail);
      if (map.current) {
        const { name } = event.detail;
        clearPreviewBoundaryByNameAndType(name, 'city');
      }
    };
    
    // Add event listeners
    window.addEventListener('city-preview-show', handleCityPreviewShow as EventListener);
    window.addEventListener('city-preview-hide', handleCityPreviewHide as EventListener);
    
    return () => {
      // Clean up event listeners
      window.removeEventListener('city-preview-show', handleCityPreviewShow as EventListener);
      window.removeEventListener('city-preview-hide', handleCityPreviewHide as EventListener);
    };
  }, []);
  
  // Listen for County preview events
  useEffect(() => {
    // Handler for showing county preview
    const handleCountyPreviewShow = (event: CustomEvent) => {
      console.log('County preview show event received:', event.detail);
      if (map.current) {
        const { name, feature } = event.detail;
        
        // Clear any existing preview for this county
        clearPreviewBoundaryByNameAndType(name, 'county');
        
        // Create unique source and layer IDs for the preview
        const sourceId = `preview-county-source-${boundarySourceCounter}`;
        const layerId = `preview-county-layer-${boundarySourceCounter}`;
        boundarySourceCounter++;
        
        // Add source and layer to map
        map.current.addSource(sourceId, {
          type: 'geojson',
          data: feature
        });
        
        // Add fill layer with a different style to indicate it's a preview
        map.current.addLayer({
          id: layerId,
          type: 'fill',
          source: sourceId,
          paint: {
            'fill-color': '#8b5cf6', // Purple color for counties
            'fill-opacity': 0.3,
            'fill-outline-color': '#8b5cf6'
          }
        });
        
        // Store the layer references for later removal
        previewBoundaryLayersRef.current.push({ sourceId, layerId, name, type: 'county' });
        
        // Fit the map to the boundary
        const bounds = new mapboxgl.LngLatBounds();
        
        // Handle both Polygon and MultiPolygon geometries
        if (feature.geometry.type === 'Polygon') {
          feature.geometry.coordinates[0].forEach((coord: number[]) => {
            bounds.extend([coord[0], coord[1]]);
          });
        } else if (feature.geometry.type === 'MultiPolygon') {
          feature.geometry.coordinates.forEach((polygon: number[][][]) => {
            polygon[0].forEach((coord: number[]) => {
              bounds.extend([coord[0], coord[1]]);
            });
          });
        }
        
        // Fly to the boundary with padding
        map.current.fitBounds(bounds, {
          padding: 50
        });
      }
    };
    
    // Handler for hiding county preview
    const handleCountyPreviewHide = (event: CustomEvent) => {
      console.log('County preview hide event received:', event.detail);
      if (map.current) {
        const { name } = event.detail;
        clearPreviewBoundaryByNameAndType(name, 'county');
      }
    };
    
    // Add event listeners
    window.addEventListener('county-preview-show', handleCountyPreviewShow as EventListener);
    window.addEventListener('county-preview-hide', handleCountyPreviewHide as EventListener);
    
    return () => {
      // Clean up event listeners
      window.removeEventListener('county-preview-show', handleCountyPreviewShow as EventListener);
      window.removeEventListener('county-preview-hide', handleCountyPreviewHide as EventListener);
    };
  }, []);
  
  // Listen for District preview events
  useEffect(() => {
    // Handler for showing district preview
    const handleDistrictPreviewShow = (event: CustomEvent) => {
      console.log('District preview show event received:', event.detail);
      if (map.current) {
        const { name, feature } = event.detail;
        
        // Clear any existing preview for this district
        clearPreviewBoundaryByNameAndType(name, 'district');
        
        // Create unique source and layer IDs for the preview
        const sourceId = `preview-district-source-${boundarySourceCounter}`;
        const layerId = `preview-district-layer-${boundarySourceCounter}`;
        boundarySourceCounter++;
        
        // Add source and layer to map
        map.current.addSource(sourceId, {
          type: 'geojson',
          data: feature
        });
        
        // Add fill layer with a different style to indicate it's a preview
        map.current.addLayer({
          id: layerId,
          type: 'fill',
          source: sourceId,
          paint: {
            'fill-color': '#3b82f6', // Blue color for districts
            'fill-opacity': 0.3,
            'fill-outline-color': '#3b82f6'
          }
        });
        
        // Store the layer references for later removal
        previewBoundaryLayersRef.current.push({ sourceId, layerId, name, type: 'district' });
        
        // Fit the map to the boundary
        const bounds = new mapboxgl.LngLatBounds();
        
        // Handle both Polygon and MultiPolygon geometries
        if (feature.geometry.type === 'Polygon') {
          feature.geometry.coordinates[0].forEach((coord: number[]) => {
            bounds.extend([coord[0], coord[1]]);
          });
        } else if (feature.geometry.type === 'MultiPolygon') {
          feature.geometry.coordinates.forEach((polygon: number[][][]) => {
            polygon[0].forEach((coord: number[]) => {
              bounds.extend([coord[0], coord[1]]);
            });
          });
        }
        
        // Fly to the boundary with padding
        map.current.fitBounds(bounds, {
          padding: 50
        });
      }
    };
    
    // Handler for hiding district preview
    const handleDistrictPreviewHide = (event: CustomEvent) => {
      console.log('District preview hide event received:', event.detail);
      if (map.current) {
        const { name } = event.detail;
        clearPreviewBoundaryByNameAndType(name, 'district');
      }
    };
    
    // Add event listeners
    window.addEventListener('district-preview-show', handleDistrictPreviewShow as EventListener);
    window.addEventListener('district-preview-hide', handleDistrictPreviewHide as EventListener);
    
    return () => {
      // Clean up event listeners
      window.removeEventListener('district-preview-show', handleDistrictPreviewShow as EventListener);
      window.removeEventListener('district-preview-hide', handleDistrictPreviewHide as EventListener);
    };
  }, []);
  
  // Listen for Subdistrict preview events
  useEffect(() => {
    // Handler for showing subdistrict preview
    const handleSubdistrictPreviewShow = (event: CustomEvent) => {
      console.log('Subdistrict preview show event received:', event.detail);
      if (map.current) {
        const { name, feature } = event.detail;
        
        // Clear any existing preview for this subdistrict
        clearPreviewBoundaryByNameAndType(name, 'subdistrict');
        
        // Create unique source and layer IDs for the preview
        const sourceId = `preview-subdistrict-source-${boundarySourceCounter}`;
        const layerId = `preview-subdistrict-layer-${boundarySourceCounter}`;
        boundarySourceCounter++;
        
        // Add source and layer to map
        map.current.addSource(sourceId, {
          type: 'geojson',
          data: feature
        });
        
        // Add fill layer with a different style to indicate it's a preview
        map.current.addLayer({
          id: layerId,
          type: 'fill',
          source: sourceId,
          paint: {
            'fill-color': '#93c5fd', // Light blue color for subdistricts
            'fill-opacity': 0.3,
            'fill-outline-color': '#93c5fd'
          }
        });
        
        // Store the layer references for later removal
        previewBoundaryLayersRef.current.push({ sourceId, layerId, name, type: 'subdistrict' });
        
        // Fit the map to the boundary
        const bounds = new mapboxgl.LngLatBounds();
        
        // Handle both Polygon and MultiPolygon geometries
        if (feature.geometry.type === 'Polygon') {
          feature.geometry.coordinates[0].forEach((coord: number[]) => {
            bounds.extend([coord[0], coord[1]]);
          });
        } else if (feature.geometry.type === 'MultiPolygon') {
          feature.geometry.coordinates.forEach((polygon: number[][][]) => {
            polygon[0].forEach((coord: number[]) => {
              bounds.extend([coord[0], coord[1]]);
            });
          });
        }
        
        // Fly to the boundary with padding
        map.current.fitBounds(bounds, {
          padding: 50
        });
      }
    };
    
    // Handler for hiding subdistrict preview
    const handleSubdistrictPreviewHide = (event: CustomEvent) => {
      console.log('Subdistrict preview hide event received:', event.detail);
      if (map.current) {
        const { name } = event.detail;
        clearPreviewBoundaryByNameAndType(name, 'subdistrict');
      }
    };
    
    // Add event listeners
    window.addEventListener('subdistrict-preview-show', handleSubdistrictPreviewShow as EventListener);
    window.addEventListener('subdistrict-preview-hide', handleSubdistrictPreviewHide as EventListener);
    
    return () => {
      // Clean up event listeners
      window.removeEventListener('subdistrict-preview-show', handleSubdistrictPreviewShow as EventListener);
      window.removeEventListener('subdistrict-preview-hide', handleSubdistrictPreviewHide as EventListener);
    };
  }, []);
  
  // Listen for selection added events to clear previews
  useEffect(() => {
    const handleSelectionAdded = () => {
      console.log('Selection added, clearing all previews');
      clearAllPreviews();
    };
    
    // Add event listeners for all selection added events
    window.addEventListener('poi-selection-added', handleSelectionAdded);
    window.addEventListener('road-selection-added', handleSelectionAdded);
    window.addEventListener('city-boundary-added', handleSelectionAdded);
    window.addEventListener('county-boundary-added', handleSelectionAdded);
    window.addEventListener('district-boundary-added', handleSelectionAdded);
    window.addEventListener('subdistrict-boundary-added', handleSelectionAdded);
    
    return () => {
      // Clean up event listeners
      window.removeEventListener('poi-selection-added', handleSelectionAdded);
      window.removeEventListener('road-selection-added', handleSelectionAdded);
      window.removeEventListener('city-boundary-added', handleSelectionAdded);
      window.removeEventListener('county-boundary-added', handleSelectionAdded);
      window.removeEventListener('district-boundary-added', handleSelectionAdded);
      window.removeEventListener('subdistrict-boundary-added', handleSelectionAdded);
    };
  }, []);
  
  // Listen for City boundary events from LocationSelector
  useEffect(() => {
    const handleCityBoundary = (event: CustomEvent) => {
      console.log('City boundary event received:', event.detail);
      if (map.current) {
        const { name, feature, type } = event.detail;
        
        // Create unique source and layer IDs
        const sourceId = `boundary-source-${boundarySourceCounter}`;
        const layerId = `boundary-layer-${boundarySourceCounter}`;
        boundarySourceCounter++;
        
        // Add source and layer to map
        map.current.addSource(sourceId, {
          type: 'geojson',
          data: feature
        });
        
        // Add fill layer
        map.current.addLayer({
          id: layerId,
          type: 'fill',
          source: sourceId,
          paint: {
            'fill-color': '#10b981', // Green color for cities
            'fill-opacity': 0.2,
            'fill-outline-color': '#10b981'
          }
        });
        
        // Store the layer references for later removal
        boundaryLayersRef.current.push({ sourceId, layerId, name, type });
        
        // Fit the map to the boundary
        const bounds = new mapboxgl.LngLatBounds();
        
        // Handle both Polygon and MultiPolygon geometries
        if (feature.geometry.type === 'Polygon') {
          feature.geometry.coordinates[0].forEach((coord: number[]) => {
            bounds.extend([coord[0], coord[1]]);
          });
        } else if (feature.geometry.type === 'MultiPolygon') {
          feature.geometry.coordinates.forEach((polygon: number[][][]) => {
            polygon[0].forEach((coord: number[]) => {
              bounds.extend([coord[0], coord[1]]);
            });
          });
        }
        
        // Fly to the boundary with padding
        map.current.fitBounds(bounds, {
          padding: 50
        });
      }
    };
    
    // Add event listener for City boundary events
    window.addEventListener('city-boundary-added', handleCityBoundary as EventListener);
    
    return () => {
      // Clean up event listener
      window.removeEventListener('city-boundary-added', handleCityBoundary as EventListener);
    };
  }, []);
  
  // Listen for County boundary events from LocationSelector
  useEffect(() => {
    const handleCountyBoundary = (event: CustomEvent) => {
      console.log('County boundary event received:', event.detail);
      if (map.current) {
        const { name, feature, type } = event.detail;
        
        // Create unique source and layer IDs
        const sourceId = `boundary-source-${boundarySourceCounter}`;
        const layerId = `boundary-layer-${boundarySourceCounter}`;
        boundarySourceCounter++;
        
        // Add source and layer to map
        map.current.addSource(sourceId, {
          type: 'geojson',
          data: feature
        });
        
        // Add fill layer
        map.current.addLayer({
          id: layerId,
          type: 'fill',
          source: sourceId,
          paint: {
            'fill-color': '#8b5cf6', // Purple color for counties
            'fill-opacity': 0.2,
            'fill-outline-color': '#8b5cf6'
          }
        });
        
        // Store the layer references for later removal
        boundaryLayersRef.current.push({ sourceId, layerId, name, type });
        
        // Fit the map to the boundary
        const bounds = new mapboxgl.LngLatBounds();
        
        // Handle both Polygon and MultiPolygon geometries
        if (feature.geometry.type === 'Polygon') {
          feature.geometry.coordinates[0].forEach((coord: number[]) => {
            bounds.extend([coord[0], coord[1]]);
          });
        } else if (feature.geometry.type === 'MultiPolygon') {
          feature.geometry.coordinates.forEach((polygon: number[][][]) => {
            polygon[0].forEach((coord: number[]) => {
              bounds.extend([coord[0], coord[1]]);
            });
          });
        }
        
        // Fly to the boundary with padding
        map.current.fitBounds(bounds, {
          padding: 50
        });
      }
    };
    
    // Add event listener for County boundary events
    window.addEventListener('county-boundary-added', handleCountyBoundary as EventListener);
    
    return () => {
      // Clean up event listener
      window.removeEventListener('county-boundary-added', handleCountyBoundary as EventListener);
    };
  }, []);
  
  // Listen for District boundary events from LocationSelector
  useEffect(() => {
    const handleDistrictBoundary = (event: CustomEvent) => {
      console.log('District boundary event received:', event.detail);
      if (map.current) {
        const { name, feature, type } = event.detail;
        
        // Create unique source and layer IDs
        const sourceId = `boundary-source-${boundarySourceCounter}`;
        const layerId = `boundary-layer-${boundarySourceCounter}`;
        boundarySourceCounter++;
        
        // Add source and layer to map
        map.current.addSource(sourceId, {
          type: 'geojson',
          data: feature
        });
        
        // Add fill layer
        map.current.addLayer({
          id: layerId,
          type: 'fill',
          source: sourceId,
          paint: {
            'fill-color': '#3b82f6', // Blue color for districts
            'fill-opacity': 0.2,
            'fill-outline-color': '#3b82f6'
          }
        });
        
        // Store the layer references for later removal
        boundaryLayersRef.current.push({ sourceId, layerId, name, type });
        
        // Fit the map to the boundary
        const bounds = new mapboxgl.LngLatBounds();
        
        // Handle both Polygon and MultiPolygon geometries
        if (feature.geometry.type === 'Polygon') {
          feature.geometry.coordinates[0].forEach((coord: number[]) => {
            bounds.extend([coord[0], coord[1]]);
          });
        } else if (feature.geometry.type === 'MultiPolygon') {
          feature.geometry.coordinates.forEach((polygon: number[][][]) => {
            polygon[0].forEach((coord: number[]) => {
              bounds.extend([coord[0], coord[1]]);
            });
          });
        }
        
        // Fly to the boundary with padding
        map.current.fitBounds(bounds, {
          padding: 50
        });
      }
    };
    
    // Add event listener for District boundary events
    window.addEventListener('district-boundary-added', handleDistrictBoundary as EventListener);
    
    return () => {
      // Clean up event listener
      window.removeEventListener('district-boundary-added', handleDistrictBoundary as EventListener);
    };
  }, []);
  
  // Listen for Subdistrict boundary events from LocationSelector
  useEffect(() => {
    const handleSubdistrictBoundary = (event: CustomEvent) => {
      console.log('Subdistrict boundary event received:', event.detail);
      if (map.current) {
        const { name, feature, type } = event.detail;
        
        // Create unique source and layer IDs
        const sourceId = `boundary-source-${boundarySourceCounter}`;
        const layerId = `boundary-layer-${boundarySourceCounter}`;
        boundarySourceCounter++;
        
        // Add source and layer to map
        map.current.addSource(sourceId, {
          type: 'geojson',
          data: feature
        });
        
        // Add fill layer
        map.current.addLayer({
          id: layerId,
          type: 'fill',
          source: sourceId,
          paint: {
            'fill-color': '#60a5fa', // Light blue color for subdistricts
            'fill-opacity': 0.2,
            'fill-outline-color': '#60a5fa'
          }
        });
        
        // Store the layer references for later removal
        boundaryLayersRef.current.push({ sourceId, layerId, name, type });
        
        // Fit the map to the boundary
        const bounds = new mapboxgl.LngLatBounds();
        
        // Handle both Polygon and MultiPolygon geometries
        if (feature.geometry.type === 'Polygon') {
          feature.geometry.coordinates[0].forEach((coord: number[]) => {
            bounds.extend([coord[0], coord[1]]);
          });
        } else if (feature.geometry.type === 'MultiPolygon') {
          feature.geometry.coordinates.forEach((polygon: number[][][]) => {
            polygon[0].forEach((coord: number[]) => {
              bounds.extend([coord[0], coord[1]]);
            });
          });
        }
        
        // Fly to the boundary with padding
        map.current.fitBounds(bounds, {
          padding: 50
        });
      }
    };
    
    // Add event listener for Subdistrict boundary events
    window.addEventListener('subdistrict-boundary-added', handleSubdistrictBoundary as EventListener);
    
    return () => {
      // Clean up event listener
      window.removeEventListener('subdistrict-boundary-added', handleSubdistrictBoundary as EventListener);
    };
  }, []);
  
  // Listen for Intersection events from LocationSelector
  useEffect(() => {
    const handleIntersection = (event: CustomEvent) => {
      console.log('Intersection event received:', event.detail);
      if (map.current) {
        const { roadName, subdivisionName, subdivisionType, roadFeature, subdivisionFeature, intersectionFeatures } = event.detail;
        
        // Create unique source and layer IDs for the intersection
        const intersectionSourceId = `intersection-source-${boundarySourceCounter}`;
        const intersectionLayerId = `intersection-layer-${boundarySourceCounter}`;
        boundarySourceCounter++;
        
        // Create unique source and layer IDs for the road
        const roadSourceId = `road-source-${boundarySourceCounter}`;
        const roadLayerId = `road-layer-${boundarySourceCounter}`;
        boundarySourceCounter++;
        
        console.log(`Creating intersection between ${roadName} and ${subdivisionName}`);
        console.log('Intersection features:', intersectionFeatures);
        
        // Only show the portion of the road between intersection points
        console.log('Creating road segment between intersection points');
        
        // Create a feature collection for the road segment between intersections
        let roadSegmentFeature: GeoJSON.Feature | null = null;
        let roadFeatureCollection: GeoJSON.FeatureCollection;
        
        // Only create the road segment if we have at least 2 intersection points
        if (intersectionFeatures && intersectionFeatures.length >= 2) {
          // Extract coordinates from the intersection points
          const point1 = intersectionFeatures[0].geometry.coordinates;
          const point2 = intersectionFeatures[intersectionFeatures.length - 1].geometry.coordinates;
          
          // Create a LineString feature between the two intersection points
          roadSegmentFeature = turf.lineString([point1, point2], { name: `${roadName} segment` });
          console.log('Created road segment between intersection points:', roadSegmentFeature);
          
          roadFeatureCollection = {
            type: 'FeatureCollection',
            features: [roadSegmentFeature]
          };
        } else if (roadFeature.type === 'FeatureCollection') {
          // Fallback to the entire road if we don't have enough intersection points
          console.log(`Using provided road collection with ${roadFeature.features.length} features`);
          roadFeatureCollection = roadFeature;
        } else {
          // Fallback to single feature
          console.log('Creating feature collection from single road feature');
          roadFeatureCollection = {
            type: 'FeatureCollection',
            features: [roadFeature]
          };
        }
        
        // Add road source to map
        map.current.addSource(roadSourceId, {
          type: 'geojson',
          data: roadFeatureCollection
        });
        
        // Add a visible layer for the road with a distinct style
        map.current.addLayer({
          id: roadLayerId,
          type: 'line',
          source: roadSourceId,
          paint: {
            'line-color': '#3b82f6', // Blue for the road
            'line-width': 5,
            'line-opacity': 0.8
          }
        });
        
        // Store the road layer info for later removal
        boundaryLayersRef.current.push({
          name: `${roadName}-road`,
          type: 'intersection-road',
          sourceId: roadSourceId,
          layerId: roadLayerId
        });
        
        // If we have intersection points, add them as a separate layer
        if (intersectionFeatures && intersectionFeatures.length > 0) {
          console.log('Adding intersection points to map');
          // Create a feature collection from the intersection features
          const intersectionFeatureCollection: GeoJSON.FeatureCollection = {
              type: 'FeatureCollection',
              features: intersectionFeatures
            };
            
          // Add source to map
          map.current.addSource(intersectionSourceId, {
            type: 'geojson',
            data: intersectionFeatureCollection
          });
          
          // Add a visible layer for the intersection points
          map.current.addLayer({
              id: intersectionLayerId,
              type: 'circle',
              source: intersectionSourceId,
              paint: {
                'circle-radius': 8,
                'circle-color': '#ef4444',  // Red for intersection points
                'circle-opacity': 0.8,
                'circle-stroke-width': 2,
                'circle-stroke-color': '#ffffff'
              }
            });
            
            // Store the intersection info for later removal
            boundaryLayersRef.current.push({
              name: `${roadName}-${subdivisionName}-intersection-points`,
              type: 'intersection-points',
              sourceId: intersectionSourceId,
              layerId: intersectionLayerId
            });
        } else {
          // If no specific intersection points, create a marker at the center of the subdivision
          console.log('No specific intersection points found, creating marker at subdivision center');
          
          const customIntersection: GeoJSON.Feature<GeoJSON.Point> = {
              type: 'Feature',
              properties: {
                name: `${roadName} ∩ ${subdivisionName}`,
                description: 'Intersection Area'
              },
              geometry: {
                type: 'Point',
                coordinates: [0, 0]  // Will be updated below
              }
            };
            
          // Get a center point from the subdivision feature
          const center = turf.center(subdivisionFeature);
          customIntersection.geometry.coordinates = center.geometry.coordinates;
          
          // Add source to map
          map.current.addSource(intersectionSourceId, {
              type: 'geojson',
              data: customIntersection
            });
            
          // Add a visible layer for the custom intersection
          map.current.addLayer({
              id: intersectionLayerId,
              type: 'circle',
              source: intersectionSourceId,
              paint: {
                'circle-radius': 8,
                'circle-color': '#ff9800',  // Orange for custom intersection
                'circle-opacity': 0.8,
                'circle-stroke-width': 2,
                'circle-stroke-color': '#ffffff'
              }
            });
            
            // Store the intersection info for later removal
            boundaryLayersRef.current.push({
              name: `${roadName}-${subdivisionName}-intersection`,
              type: 'intersection',
              sourceId: intersectionSourceId,
              layerId: intersectionLayerId
            });
        }
        
        // Fit the map to show both the road and the subdivision
        try {
          // Create a bounding box that includes both the road and subdivision
          let roadBbox;
          
          // Handle road feature collection or single feature
          if (roadFeature.type === 'FeatureCollection') {
            // Calculate bbox from the entire feature collection
            roadBbox = turf.bbox(roadFeature);
            console.log('Calculated bbox from road collection:', roadBbox);
          } else {
            roadBbox = turf.bbox(roadFeature);
            console.log('Calculated bbox from single road feature:', roadBbox);
          }
          
          const subdivisionBbox = turf.bbox(subdivisionFeature);
          console.log('Subdivision bbox:', subdivisionBbox);
          
          // Combine the bounding boxes
          const combinedBbox = [
              Math.min(roadBbox[0], subdivisionBbox[0]),
              Math.min(roadBbox[1], subdivisionBbox[1]),
              Math.max(roadBbox[2], subdivisionBbox[2]),
              Math.max(roadBbox[3], subdivisionBbox[3])
            ];
            
          // Fit the map to the combined bounding box
          map.current.fitBounds([
              [combinedBbox[0], combinedBbox[1]], // Southwest coordinates
              [combinedBbox[2], combinedBbox[3]]  // Northeast coordinates
            ], { padding: 50 });
        } catch (error) {
          console.error('Error fitting map to intersection area:', error);
        }
      }
    };
    
    // Add event listener for Intersection events
    window.addEventListener('intersection-added', handleIntersection as EventListener);
    
    return () => {
      // Clean up event listener
      window.removeEventListener('intersection-added', handleIntersection as EventListener);
    };
  }, []);
  
  // Listen for selection removal events from LocationSelector
  useEffect(() => {
    const handleSelectionRemoved = (event: CustomEvent) => {
      console.log('Selection removed event received:', event.detail);
      if (map.current) {
        const { type, selection } = event.detail;
        
        if (type === 'road') {
          // Find and remove the road layer and source
          const roadLayerIndex = roadLayersRef.current.findIndex(layer => {
            // Check if this layer's source data has the same name property
            if (map.current?.getSource(layer.sourceId)) {
              try {
                const source = map.current.getSource(layer.sourceId) as mapboxgl.GeoJSONSource;
                const data = source._data as any;
                return data?.properties?.name === selection;
              } catch (e) {
                return false;
              }
            }
            return false;
          });
          
          if (roadLayerIndex >= 0) {
            const { sourceId, layerId } = roadLayersRef.current[roadLayerIndex];
            
            // Remove the layer and source from the map
            if (map.current.getLayer(layerId)) {
              map.current.removeLayer(layerId);
            }
            if (map.current.getSource(sourceId)) {
              map.current.removeSource(sourceId);
            }
            
            // Remove from our tracking array
            roadLayersRef.current.splice(roadLayerIndex, 1);
            console.log(`Removed road layer for ${selection}`);
          }
        } else if (type === 'city') {
          // Check if this is a Point of Interest (has poiRadius property)
          if (event.detail.poiRadius !== undefined) {
            console.log('Removing Point of Interest:', selection);
            
            // Clear POI markers (both preview and selection markers)
            if (poiMarkersRef.current.length > 0) {
              console.log('Looking for POI markers with name:', selection);
              
              // Find markers with the matching POI name (regardless of type)
              const markersToRemove = poiMarkersRef.current.filter(marker => {
                const element = marker.getElement();
                const markerName = element.getAttribute('data-poi-name');
                console.log('Checking marker:', markerName, 'against selection:', selection);
                return markerName === selection;
              });
              
              console.log('Found', markersToRemove.length, 'markers to remove');
              
              // Remove the markers from the map
              markersToRemove.forEach(marker => {
                console.log('Removing marker from map');
                marker.remove();
              });
              
              // Update the markers reference array
              poiMarkersRef.current = poiMarkersRef.current.filter(marker => {
                const element = marker.getElement();
                return element.getAttribute('data-poi-name') !== selection;
              });
            }
            
            // Clear POI circle layers
            if (map.current && poiCircleLayersRef.current.length > 0) {
              // Find circle layers with the matching POI name
              const circlesToRemove = poiCircleLayersRef.current.filter(circle => circle.poiName === selection);
              
              // Remove the layers and sources from the map
              circlesToRemove.forEach(({sourceId, layerId}) => {
                if (map.current?.getLayer(layerId)) {
                  map.current.removeLayer(layerId);
                }
                if (map.current?.getSource(sourceId)) {
                  map.current.removeSource(sourceId);
                }
              });
              
              // Update the circle layers reference array
              poiCircleLayersRef.current = poiCircleLayersRef.current.filter(circle => circle.poiName !== selection);
            }
          } else {
            // Handle regular city boundaries
            // If a specific city is provided, remove just that one
            if (selection) {
              clearBoundaryByNameAndType(selection, 'city');
            } else {
              // Otherwise clear all city boundaries
              const cityBoundaries = boundaryLayersRef.current.filter(b => b.type === 'city');
              cityBoundaries.forEach(({sourceId, layerId}) => {
                if (map.current?.getLayer(layerId)) {
                  map.current.removeLayer(layerId);
                }
                if (map.current?.getSource(sourceId)) {
                  map.current.removeSource(sourceId);
                }
              });
              boundaryLayersRef.current = boundaryLayersRef.current.filter(b => b.type !== 'city');
            }
          }
        } else if (type === 'county') {
          // If a specific county is provided, remove just that one
          if (selection) {
            clearBoundaryByNameAndType(selection, 'county');
          } else {
            // Otherwise clear all county boundaries
            const countyBoundaries = boundaryLayersRef.current.filter(b => b.type === 'county');
            countyBoundaries.forEach(({sourceId, layerId}) => {
              if (map.current?.getLayer(layerId)) {
                map.current.removeLayer(layerId);
              }
              if (map.current?.getSource(sourceId)) {
                map.current.removeSource(sourceId);
              }
            });
            boundaryLayersRef.current = boundaryLayersRef.current.filter(b => b.type !== 'county');
          }
        } else if (type === 'district') {
          // If a specific district is provided, remove just that one
          if (selection) {
            clearBoundaryByNameAndType(selection, 'district');
          } else {
            // Otherwise clear all district boundaries
            const districtBoundaries = boundaryLayersRef.current.filter(b => b.type === 'district');
            districtBoundaries.forEach(({sourceId, layerId}) => {
              if (map.current?.getLayer(layerId)) {
                map.current.removeLayer(layerId);
              }
              if (map.current?.getSource(sourceId)) {
                map.current.removeSource(sourceId);
              }
            });
            boundaryLayersRef.current = boundaryLayersRef.current.filter(b => b.type !== 'district');
          }
        } else if (type === 'subdistrict') {
          // If a specific subdistrict is provided, remove just that one
          if (selection) {
            clearBoundaryByNameAndType(selection, 'subdistrict');
          } else {
            // Otherwise clear all subdistrict boundaries
            const subdistrictBoundaries = boundaryLayersRef.current.filter(b => b.type === 'subdistrict');
            subdistrictBoundaries.forEach(({sourceId, layerId}) => {
              if (map.current?.getLayer(layerId)) {
                map.current.removeLayer(layerId);
              }
              if (map.current?.getSource(sourceId)) {
                map.current.removeSource(sourceId);
              }
            });
            boundaryLayersRef.current = boundaryLayersRef.current.filter(b => b.type !== 'subdistrict');
          }
        }
      }
    };
    
    // Add event listener for selection removal events
    window.addEventListener('selection-removed', handleSelectionRemoved as EventListener);
    
    return () => {
      // Clean up event listener
      window.removeEventListener('selection-removed', handleSelectionRemoved as EventListener);
    };
  }, []);
  
  // Listen for draw mode changes from LocationSelector
  useEffect(() => {
    const handleDrawModeChange = (event: CustomEvent) => {
      console.log('Draw mode change event received:', event.detail);
      if (map.current && drawRef.current) {
        const { mode } = event.detail;
        
        if (mode === 'polygon') {
          // Activate polygon drawing mode
          drawRef.current.changeMode('draw_polygon');
          setDrawModeActive(true);
        } else if (mode === 'circle') {
          // Activate circle drawing mode (not directly supported by MapboxDraw)
          // For now, we'll use polygon as a fallback
          drawRef.current.changeMode('draw_polygon');
          setDrawModeActive(true);
        } else {
          // Deactivate drawing mode
          drawRef.current.changeMode('simple_select');
          setDrawModeActive(false);
        }
      }
    };

    // Add event listener for custom draw mode change event
    window.addEventListener('location-draw-mode-change', handleDrawModeChange as EventListener);
    
    return () => {
      // Clean up event listener
      window.removeEventListener('location-draw-mode-change', handleDrawModeChange as EventListener);
    };
  }, []);
  
  // Initialize map
  useEffect(() => {
    if (map.current) return;

    if (mapContainer.current) {
      console.log('Initializing map...');
      mapboxgl.accessToken = 'pk.eyJ1IjoidGFuYXkyayIsImEiOiJjbTJpYnltejYwbDgwMmpvbm1lNG16enV3In0.fwcdZ3I-cofnDOR9m1Hqng';
      
      map.current = new mapboxgl.Map({
        container: mapContainer.current,
        style: "mapbox://styles/mapbox/navigation-day-v1",
        center: [-86.1581, 39.7684],
        zoom: 7
      });
      
      // Initialize draw control
      drawRef.current = new MapboxDraw({
        displayControlsDefault: false,
        controls: {
          polygon: true,
          trash: true
        },
        defaultMode: 'simple_select'
      });
      
      // Add draw control to the map
      map.current.addControl(drawRef.current, 'top-right');

      // Add event listeners to track map loading
      if (map.current) {
        map.current.on('load', () => {
          console.log('Map loaded successfully!');
        
          // Initialize the cluster source
          if (!map.current) return;
          
          map.current.addSource(CLUSTER_SOURCE_ID, {
          type: 'geojson',
          data: {
            type: 'FeatureCollection',
            features: []
          },
          cluster: true,
          clusterMaxZoom: 14, // Max zoom to cluster points on
          clusterRadius: 50 // Radius of each cluster when clustering points
        });
        
          // Add a layer for the clusters
          if (!map.current) return;
          
          map.current.addLayer({
          id: CLUSTER_LAYER_ID,
          type: 'circle',
          source: CLUSTER_SOURCE_ID,
          filter: ['has', 'point_count'],
          paint: {
            'circle-color': '#297fb8', // Same color for all clusters
            'circle-radius': [
              'step',
              ['get', 'point_count'],
              20, // Size for clusters with < 10 points
              10,
              30, // Size for clusters with 10-50 points
              50,
              40 // Size for clusters with > 50 points
            ],
            'circle-stroke-width': 2,
            'circle-stroke-color': '#fff'
          }
        });
        
          // Add a layer for the cluster counts
          if (!map.current) return;
          
          map.current.addLayer({
          id: CLUSTER_COUNT_LAYER_ID,
          type: 'symbol',
          source: CLUSTER_SOURCE_ID,
          filter: ['has', 'point_count'],
          layout: {
            'text-field': '{point_count_abbreviated}',
            'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
            'text-size': 12
          },
          paint: {
            'text-color': '#ffffff'
          }
        });
        
          // Add a layer for individual points
          if (!map.current) return;
          
          map.current.addLayer({
          id: UNCLUSTERED_POINT_LAYER_ID,
          type: 'circle',
          source: CLUSTER_SOURCE_ID,
          filter: ['!', ['has', 'point_count']],
          paint: {
            'circle-color': ['get', 'color'],
            'circle-radius': 10,
            'circle-stroke-width': 2,
            'circle-stroke-color': '#fff'
          }
        });
        
          // Add a layer for individual point count (showing '1')
          if (!map.current) return;
          
          map.current.addLayer({
          id: 'unclustered-point-count',
          type: 'symbol',
          source: CLUSTER_SOURCE_ID,
          filter: ['!', ['has', 'point_count']],
          layout: {
            'text-field': '1',
            'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
            'text-size': 10
          },
          paint: {
            'text-color': '#ffffff'
          }
        });
        
          // Add click event for clusters
          if (!map.current) return;
          
          map.current.on('click', CLUSTER_LAYER_ID, (e) => {
          if (!map.current) return;
          const features = map.current.queryRenderedFeatures(e.point, { layers: [CLUSTER_LAYER_ID] });
          if (!features || features.length === 0) return;
          
          const clusterId = features[0].properties?.cluster_id;
          if (!clusterId) return;
          
          const source = map.current.getSource(CLUSTER_SOURCE_ID) as mapboxgl.GeoJSONSource;
          if (!source) return;
          
          source.getClusterExpansionZoom(clusterId, (err, zoom) => {
            if (err || !map.current || !features[0].geometry) return;
            
            const coordinates = (features[0].geometry as any).coordinates;
            if (!coordinates) return;
            
            map.current.easeTo({
              center: coordinates as [number, number],
              zoom: zoom || map.current.getZoom() + 1 // Fallback zoom level if null
            });
          });
        });
        
          // Add click event for individual points to show popup
          if (!map.current) return;
          
          map.current.on('click', UNCLUSTERED_POINT_LAYER_ID, (e) => {
          if (!map.current) return;
          const features = map.current.queryRenderedFeatures(e.point, { layers: [UNCLUSTERED_POINT_LAYER_ID] });
          if (!features || features.length === 0) return;
          
          const feature = features[0];
          if (!feature.geometry) return;
          
          const coordinates = (feature.geometry as any).coordinates?.slice() as [number, number];
          if (!coordinates) return;
          
          const properties = feature.properties;
          if (!properties) return;
          
          // Create popup content from properties
          const popupContent = properties.popupContent || 'No information available';
          
          // Create popup
          if (map.current) {
            new mapboxgl.Popup()
              .setLngLat(coordinates)
              .setHTML(popupContent)
              .addTo(map.current);
          }
        });
        
          // Change cursor to pointer when hovering over clusters or points
          if (!map.current) return;
          
          map.current.on('mouseenter', CLUSTER_LAYER_ID, () => {
            if (map.current && map.current.getCanvas()) {
              map.current.getCanvas().style.cursor = 'pointer';
            }
          });
          
          if (!map.current) return;
          
          map.current.on('mouseleave', CLUSTER_LAYER_ID, () => {
            if (map.current && map.current.getCanvas()) {
              map.current.getCanvas().style.cursor = '';
            }
          });
          
          if (!map.current) return;
          
          map.current.on('mouseenter', UNCLUSTERED_POINT_LAYER_ID, () => {
            if (map.current && map.current.getCanvas()) {
              map.current.getCanvas().style.cursor = 'pointer';
            }
          });
          
          if (!map.current) return;
          
          map.current.on('mouseleave', UNCLUSTERED_POINT_LAYER_ID, () => {
            if (map.current && map.current.getCanvas()) {
              map.current.getCanvas().style.cursor = '';
            }
          });
        });
      }
      
      // Add draw event listeners
      map.current.on('draw.create', (e: any) => {
        console.log('Draw created:', e.features);
        
        // Capture the drawn polygon coordinates
        if (e.features && e.features.length > 0) {
          const feature = e.features[0];
          const coordinates = feature.geometry.coordinates;
          const featureId = feature.id;
          
          // Dispatch event with polygon data to be received by LocationSelector
          const event = new CustomEvent('location-polygon-drawn', {
            detail: {
              featureId,
              type: feature.geometry.type,
              coordinates,
              boundingBox: getBoundingBox(coordinates[0]) // For polygons, use the outer ring
            }
          });
          window.dispatchEvent(event);
        }
      });
      
      map.current.on('draw.update', (e: any) => {
        console.log('Draw updated:', e.features);
        
        // Handle updated polygon
        if (e.features && e.features.length > 0) {
          const feature = e.features[0];
          const coordinates = feature.geometry.coordinates;
          const featureId = feature.id;
          
          // Dispatch event with updated polygon data
          const event = new CustomEvent('location-polygon-updated', {
            detail: {
              featureId,
              type: feature.geometry.type,
              coordinates,
              boundingBox: getBoundingBox(coordinates[0]) // For polygons, use the outer ring
            }
          });
          window.dispatchEvent(event);
        }
      });
      
      map.current.on('draw.delete', (e: any) => {
        console.log('Draw deleted:', e.features);
        
        // Notify that polygons were deleted
        if (e.features && e.features.length > 0) {
          const featureIds = e.features.map((f: any) => f.id);
          
          // Dispatch event with deleted polygon IDs
          const event = new CustomEvent('location-polygon-deleted', {
            detail: {
              featureIds
            }
          });
          window.dispatchEvent(event);
        }
      });

      map.current.on('error', (e) => {
        console.error('Map error:', e);
      });

      map.current.addControl(new mapboxgl.NavigationControl(), "bottom-right");
      
      // Create a ResizeObserver to watch for container size changes
      resizeObserverRef.current = new ResizeObserver(() => {
        if (map.current) {
          // Slight delay to ensure the container has fully resized
          setTimeout(() => {
            if (map.current) {
              map.current.resize();
            }
          }, 0);
        }
      });
      
      // Start observing the map container
      resizeObserverRef.current.observe(mapContainer.current);
    }

    return () => {
      // Clean up the observer and map when component unmounts
      if (resizeObserverRef.current && mapContainer.current) {
        resizeObserverRef.current.unobserve(mapContainer.current);
        resizeObserverRef.current.disconnect();
      }
      
      if (map.current) {
        map.current.remove();
        map.current = null;
      }
    };
  }, []);
  
  // Process and display map data when queryResults change
  useEffect(() => {
    if (!map.current || !queryResults) {
      console.log('Map or query results not available', { map: !!map.current, queryResults: !!queryResults });
      return;
    }
    
    console.log('Processing query results for map visualization');
    
    // Clear existing markers
    clearMarkers();
    
    // Reset visible datasets when clearing markers
    setVisibleDatasets(new Set());
    // Also reset selected datasets
    setSelectedDatasets(new Set());
    
    // Log the structure of the query results to help with debugging
    console.log('Query results structure:', {
      isArray: Array.isArray(queryResults.results),
      length: Array.isArray(queryResults.results) ? queryResults.results.length : 'N/A',
      keys: typeof queryResults.results === 'object' ? Object.keys(queryResults.results) : 'N/A'
    });
    
    // Track all datasets we've processed to avoid duplicates
    const processedDatasets = new Set<string>();
    
    // First, try to process as array format (results[0][tableName])
    if (queryResults.results && Array.isArray(queryResults.results) && queryResults.results.length > 0) {
      console.log('Processing results in array format');
      
      for (let i = 0; i < queryResults.results.length; i++) {
        const resultsObj = queryResults.results[i];
        
        if (resultsObj && typeof resultsObj === 'object') {
          // Process each dataset's results
          Object.entries(resultsObj).forEach(([tableName, items]) => {
            // Skip if we've already processed this dataset
            if (processedDatasets.has(tableName)) {
              console.log(`Skipping duplicate dataset: ${tableName}`);
              return;
            }
            
            processedDatasets.add(tableName);
            
            // Add to selected datasets if it has items, regardless of visibility
            if (Array.isArray(items) && items.length > 0) {
              setSelectedDatasets(prev => {
                const newSet = new Set(prev);
                newSet.add(tableName);
                return newSet;
              });
            }
            
            // Skip processing for map if not visible or not an array
            if (!Array.isArray(items) || !visibleLayers[tableName]) {
              console.log(`Skipping ${tableName}: Array check: ${Array.isArray(items)}, Visible: ${!!visibleLayers[tableName]}`);
              return;
            }
            
            console.log(`Processing ${items.length} items from dataset ${tableName}`);
            
            // Process each item in the dataset
            items.forEach((item: any) => {
              try {
                // Add the tableName to the item for reference
                const mapItem: MapData = {
                  ...item,
                  datasource_tablename: tableName
                };
                
                // Parse the readable_coordinates
                if (mapItem.readable_coordinates) {
                  try {
                    // Try to parse the coordinates
                    let coordinates;
                    
                    // Handle different coordinate formats
                    if (typeof mapItem.readable_coordinates === 'string') {
                      try {
                        // Try to parse as JSON
                        coordinates = JSON.parse(mapItem.readable_coordinates);
                        console.log('Successfully parsed coordinates as JSON:', coordinates);
                      } catch (jsonError) {
                        // If JSON parsing fails, try to handle as a string format
                        console.log('Failed to parse as JSON, trying alternative formats');
                        
                        // Check if it's a simple coordinate pair like "39.7684,-86.1581"
                        const coordMatch = mapItem.readable_coordinates.match(/(-?\d+\.\d+),\s*(-?\d+\.\d+)/);
                        if (coordMatch) {
                          const lat = parseFloat(coordMatch[1]);
                          const lng = parseFloat(coordMatch[2]);
                          coordinates = {
                            type: 'Point',
                            coordinates: [lng, lat]
                          };
                          console.log('Parsed as simple coordinate pair:', coordinates);
                        } else {
                          console.error('Unrecognized coordinate format:', mapItem.readable_coordinates);
                          return;
                        }
                      }
                    } else if (typeof mapItem.readable_coordinates === 'object') {
                      // It's already an object, use it directly
                      coordinates = mapItem.readable_coordinates;
                      console.log('Coordinates already in object format:', coordinates);
                    }
                    
                    // Add marker to map if we have valid coordinates
                    if (coordinates) {
                      addMarkerToMap(mapItem, coordinates);
                    }
                  } catch (parseError) {
                    console.error('Error processing coordinates:', mapItem.readable_coordinates, parseError);
                  }
                } else {
                  // Check for alternative coordinate fields
                  const possibleCoordinateFields = ['coordinates', 'geometry', 'location', 'position', 'lat_long'];
                  
                  for (const field of possibleCoordinateFields) {
                    if (mapItem[field]) {
                      console.log(`Found alternative coordinate field: ${field}`, mapItem[field]);
                      try {
                        let coordinates;
                        if (typeof mapItem[field] === 'string') {
                          coordinates = JSON.parse(mapItem[field]);
                        } else {
                          coordinates = mapItem[field];
                        }
                        
                        addMarkerToMap(mapItem, coordinates);
                        break; // Exit the loop after successfully using an alternative field
                      } catch (e) {
                        console.error(`Error using alternative field ${field}:`, e);
                      }
                    }
                  }
                  
                  console.warn('Item missing coordinates:', mapItem);
                }
              } catch (error) {
                console.error('Error processing map item:', error);
              }
            });
          });
        }
      }
    }
    
    // Then, try to process as object format (results[tableName])
    if (queryResults.results && typeof queryResults.results === 'object') {
      console.log('Processing results in object format');
      
      // Alternative format: direct object with table names as keys
      Object.entries(queryResults.results).forEach(([tableName, items]) => {
        // Skip if we've already processed this dataset
        if (processedDatasets.has(tableName)) {
          console.log(`Skipping duplicate dataset: ${tableName}`);
          return;
        }
        
        processedDatasets.add(tableName);
        
        // Add to selected datasets if it has items, regardless of visibility
        if (Array.isArray(items) && items.length > 0) {
          setSelectedDatasets(prev => {
            const newSet = new Set(prev);
            newSet.add(tableName);
            return newSet;
          });
        }
        
        if (!Array.isArray(items) || !visibleLayers[tableName]) {
          console.log(`Skipping ${tableName}: Array check: ${Array.isArray(items)}, Visible: ${!!visibleLayers[tableName]}`);
          return;
        }
        
        console.log(`Processing ${items.length} items from dataset ${tableName}`);
        
        // Process each item in the dataset
        items.forEach((item: any) => {
          try {
            // Add the tableName to the item for reference
            const mapItem: MapData = {
              ...item,
              datasource_tablename: tableName
            };
            
            // Parse the readable_coordinates
            if (mapItem.readable_coordinates) {
              try {
                // Try to parse the coordinates
                let coordinates;
                
                // Handle different coordinate formats
                if (typeof mapItem.readable_coordinates === 'string') {
                  try {
                    // Try to parse as JSON
                    coordinates = JSON.parse(mapItem.readable_coordinates);
                    console.log('Successfully parsed coordinates as JSON:', coordinates);
                  } catch (jsonError) {
                    // If JSON parsing fails, try to handle as a string format
                    console.log('Failed to parse as JSON, trying alternative formats');
                    
                    // Check if it's a simple coordinate pair like "39.7684,-86.1581"
                    const coordMatch = mapItem.readable_coordinates.match(/(-?\d+\.\d+),\s*(-?\d+\.\d+)/);
                    if (coordMatch) {
                      const lat = parseFloat(coordMatch[1]);
                      const lng = parseFloat(coordMatch[2]);
                      coordinates = {
                        type: 'Point',
                        coordinates: [lng, lat]
                      };
                      console.log('Parsed as simple coordinate pair:', coordinates);
                    } else {
                      console.error('Unrecognized coordinate format:', mapItem.readable_coordinates);
                      // Skip this item since we can't parse coordinates
                      return;
                    }
                  }
                } else if (typeof mapItem.readable_coordinates === 'object') {
                  // It's already an object, use it directly
                  coordinates = mapItem.readable_coordinates;
                  console.log('Coordinates already in object format:', coordinates);
                }
                
                // Add marker to map if we have valid coordinates
                if (coordinates) {
                  addMarkerToMap(mapItem, coordinates);
                }
              } catch (parseError) {
                console.error('Error processing coordinates:', mapItem.readable_coordinates, parseError);
              }
            } else {
              // Check for alternative coordinate fields
              const possibleCoordinateFields = ['coordinates', 'geometry', 'location', 'position', 'lat_long'];
              
              for (const field of possibleCoordinateFields) {
                if (mapItem[field]) {
                  console.log(`Found alternative coordinate field: ${field}`, mapItem[field]);
                  try {
                    let coordinates;
                    if (typeof mapItem[field] === 'string') {
                      coordinates = JSON.parse(mapItem[field]);
                    } else {
                      coordinates = mapItem[field];
                    }
                    
                    addMarkerToMap(mapItem, coordinates);
                    break; // Exit after successfully using an alternative field
                  } catch (e) {
                    console.error(`Error using alternative field ${field}:`, e);
                  }
                }
              }
              
              if (!mapItem.readable_coordinates && !possibleCoordinateFields.some(field => mapItem[field])) {
                console.warn('Item missing coordinates:', mapItem);
              }
            }
          } catch (error) {
            console.error('Error processing map item:', error);
          }
        });
      });
    } else {
      console.warn('Query results are not in the expected format:', queryResults);
    }
    
    // Fit bounds to markers if we have any
    if (markersRef.current.length > 0 && map.current) {
      const bounds = new mapboxgl.LngLatBounds();
      markersRef.current.forEach(marker => {
        bounds.extend(marker.getLngLat());
      });
      
      map.current.fitBounds(bounds, {
        padding: 50,
        maxZoom: 15
      });
      
      console.log(`Added ${markersRef.current.length} markers to the map`);
    } else {
      console.log('No markers to display on the map');
    }
          const detailedView = document.getElementById('detailed-view');
          const itemsContainer = document.getElementById('items-container');
          
          // Function to update the visible item
          function showItem(index) {
            // Hide all items
            document.querySelectorAll('.item-content').forEach(item => {
              item.style.display = 'none';
            });
            
            // Show the selected item
            const selectedItem = document.getElementById(`item-${index}`);
            if (selectedItem) {
              selectedItem.style.display = 'block';
            }
            
            // Update pagination info
            paginationInfo.textContent = `Item ${index + 1} of ${itemCount}`;
            
            // Update button states
            prevButton.disabled = index === 0;
            nextButton.disabled = index === itemCount - 1;
            
            // Update current index
            currentIndex = index;
          }
          
          // Add event listeners for pagination buttons
          prevButton.addEventListener('click', () => {
            if (currentIndex > 0) {
              showItem(currentIndex - 1);
            }
          });
          
          nextButton.addEventListener('click', () => {
            if (currentIndex < itemCount - 1) {
              showItem(currentIndex + 1);
            }
          });
          
          // Add event listeners for view details buttons
          document.querySelectorAll('.view-details-btn').forEach(button => {
            button.addEventListener('click', function() {
              const itemIndex = parseInt(this.getAttribute('data-item-index'));
              const item = ${JSON.stringify(items)}[itemIndex];
              
              // Generate detailed content for this item
              let detailedContent = `
                <div>
                  <button id="back-to-list" style="background-color: #e5e7eb; border: none; border-radius: 4px; padding: 4px 8px; margin-bottom: 12px; cursor: pointer; display: flex; align-items: center;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
                    Back to List
                  </button>
                  
                  <div style="background-color: #f3f4f6; border-radius: 6px; padding: 10px; margin-bottom: 12px;">
              `;
              
              // Add all properties
              Object.entries(item).forEach(([key, value]) => {
                // Skip internal properties
                if (['color', 'popupContent'].includes(key)) return;
                
                // Format the key for display
                const displayKey = key
                  .split('_')
                  .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                  .join(' ');
                
                // Format the value
                let displayValue = value;
                if (value === null || value === undefined) {
                  displayValue = '-';
                } else if (typeof value === 'object') {
                  try {
                    displayValue = JSON.stringify(value);
                  } catch (e) {
                    displayValue = '[Complex Object]';
                  }
                }
                
                detailedContent += `
                  <div style="margin-bottom: 6px;">
                    <strong>${displayKey}:</strong> ${displayValue}
                  </div>
                `;
              });
              
              detailedContent += `
                  </div>
                </div>
              `;
              
              // Hide the items container and show the detailed view
              itemsContainer.style.display = 'none';
              detailedView.innerHTML = detailedContent;
              detailedView.style.display = 'block';
              
              // Add event listener for back button
              document.getElementById('back-to-list').addEventListener('click', () => {
                detailedView.style.display = 'none';
                itemsContainer.style.display = 'block';
              });
            });
          });
        })();
      </script>
    `;
    
    return content;
  };
  
  // Function to create popup content with detailed information
  const createPopupContent = (item: MapData | MapData[]): string => {
    // Check if we have multiple items at the same location
    if (Array.isArray(item)) {
      return createMultiItemPopupContent(item);
    }
    
    // Get dataset display name
    const datasetDisplayName = item.datasource_tablename
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
    
    // Start with styled container and header
    let content = `
      <div class="popup-container" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; max-width: 300px; max-height: 400px; overflow-y: auto;">
        <div style="display: flex; align-items: center; justify-content: space-between; border-bottom: 2px solid #e5e7eb; padding-bottom: 8px; margin-bottom: 12px;">
          <div style="display: flex; align-items: center;">
            <div style="font-size: 24px; margin-right: 8px;">📍</div>
            <h2 style="margin: 0; font-size: 20px; font-weight: 600; color: #1f2937;">${datasetDisplayName}</h2>
          </div>
        </div>
        
        <div style="background-color: #f3f4f6; border-radius: 6px; padding: 10px; margin-bottom: 12px;">
    `;
    
    // Add all properties
    Object.entries(item).forEach(([key, value]) => {
      // Skip internal properties
      if (['color', 'popupContent'].includes(key)) return;
      
      // Format the key for display
      const displayKey = key
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
      
      // Format the value
      let displayValue = value;
      if (value === null || value === undefined) {
        displayValue = '-';
      } else if (typeof value === 'object') {
        try {
          displayValue = JSON.stringify(value);
        } catch (e) {
          displayValue = '[Complex Object]';
        }
      }
      
      content += `
        <div style="margin-bottom: 6px;">
          <strong>${displayKey}:</strong> ${displayValue}
        </div>
      `;
    });
    
    content += `
        </div>
      </div>
    `;
    
    return content;
  };
  
  // Function to create popup content for multiple items at the same location
  const createMultiItemPopupContent = (items: MapData[]): string => {
    // Start with styled container and header
    let content = `
      <div class="popup-container" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; max-width: 320px; max-height: 400px; overflow-y: auto;">
        <div style="display: flex; align-items: center; justify-content: space-between; border-bottom: 2px solid #e5e7eb; padding-bottom: 8px; margin-bottom: 12px;">
          <div style="display: flex; align-items: center;">
            <div style="font-size: 24px; margin-right: 8px;">📍</div>
            <h2 style="margin: 0; font-size: 20px; font-weight: 600; color: #1f2937;">${items.length} Items at this Location</h2>
          </div>
        </div>
        
        <div class="pagination-container" style="margin-bottom: 12px;">
          <div style="display: flex; justify-content: space-between; align-items: center;">
            <button id="prev-item" class="pagination-button" style="background-color: #e5e7eb; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; display: flex; align-items: center;" disabled>
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
              Previous
            </button>
            <span id="pagination-info" style="font-size: 14px;">Item 1 of ${items.length}</span>
            <button id="next-item" class="pagination-button" style="background-color: #e5e7eb; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; display: flex; align-items: center;">
              Next
              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>
            </button>
          </div>
        </div>
        
        <div id="items-container">
    `;
    
    // Add each item's content in a separate div that will be shown/hidden via JavaScript
    items.forEach((item, index) => {
      const isVisible = index === 0 ? 'block' : 'none';
      content += `<div id="item-${index}" class="item-content" style="display: ${isVisible};">`;      
      
      // Get dataset display name
      const datasetDisplayName = item.datasource_tablename
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
      
      content += `
        <div style="background-color: #f3f4f6; border-radius: 6px; padding: 10px; margin-bottom: 12px;">
          <div style="font-weight: 600; color: #4b5563; margin-bottom: 6px;">${datasetDisplayName}</div>
      `;
      
      // Add a subset of important properties for the summary view
      const importantProps = ['name', 'title', 'description', 'type', 'status', 'event_type', 'severity'];
      
      // Find the first available important property
      let foundImportantProp = false;
      for (const prop of importantProps) {
        if (item[prop as keyof MapData] !== undefined && item[prop as keyof MapData] !== null) {
          const displayKey = prop
            .split('_')
            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
            .join(' ');
          
          content += `<div><strong>${displayKey}:</strong> ${item[prop as keyof MapData]}</div>`;
          foundImportantProp = true;
          break;
        }
      }
      
      // If no important property was found, show the ID or a generic message
      if (!foundImportantProp) {
        content += `<div>ID: ${item.id || 'No ID available'}</div>`;
      }
      
      // Add a "View Details" button that will show the full content
      content += `
        <button class="view-details-btn" data-item-index="${index}" style="background-color: #2563eb; color: white; border: none; border-radius: 4px; padding: 4px 8px; margin-top: 8px; cursor: pointer;">
          View Details
        </button>
        </div>
      `;
      
      content += `</div>`;
    });
    
    // Add a container for the detailed view
    content += `
        <div id="detailed-view" style="display: none;"></div>
      </div>
    `;
    
    // Add JavaScript to handle pagination and detailed view
    content += `
      <script>
        (function() {
          let currentIndex = 0;
          const itemCount = ${items.length};
          const prevButton = document.getElementById('prev-item');
          const nextButton = document.getElementById('next-item');
          const paginationInfo = document.getElementById('pagination-info');
          const detailedView = document.getElementById('detailed-view');
          const itemsContainer = document.getElementById('items-container');
          
          // Function to update the visible item
          function showItem(index) {
            // Hide all items
            document.querySelectorAll('.item-content').forEach(item => {
              item.style.display = 'none';
            });
            
            // Show the selected item
            const selectedItem = document.getElementById('item-' + index);
            if (selectedItem) {
              selectedItem.style.display = 'block';
            }
            
            // Update pagination info
            paginationInfo.textContent = 'Item ' + (index + 1) + ' of ' + itemCount;
            
            // Update button states
            prevButton.disabled = index === 0;
            nextButton.disabled = index === itemCount - 1;
            
            // Update current index
            currentIndex = index;
          }
          
          // Add event listeners for pagination buttons
          prevButton.addEventListener('click', () => {
            if (currentIndex > 0) {
              showItem(currentIndex - 1);
            }
          });
          
          nextButton.addEventListener('click', () => {
            if (currentIndex < itemCount - 1) {
              showItem(currentIndex + 1);
            }
          });
          
          // Add event listeners for view details buttons
          document.querySelectorAll('.view-details-btn').forEach(button => {
            button.addEventListener('click', function() {
              const itemIndex = parseInt(this.getAttribute('data-item-index'));
              const item = ${JSON.stringify(items)}[itemIndex];
              
              // Generate detailed content for this item
              let detailedContent = '\
                <div>\
                  <button id="back-to-list" style="background-color: #e5e7eb; border: none; border-radius: 4px; padding: 4px 8px; margin-bottom: 12px; cursor: pointer; display: flex; align-items: center;">\
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>\
                    Back to List\
                  </button>\
                  \
                  <div style="background-color: #f3f4f6; border-radius: 6px; padding: 10px; margin-bottom: 12px;">\
              ';
              
              // Add all properties
              Object.entries(item).forEach(([key, value]) => {
                // Skip internal properties
                if (['color', 'popupContent'].includes(key)) return;
                
                // Format the key for display
                const displayKey = key
                  .split('_')
                  .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                  .join(' ');
                
                // Format the value
                let displayValue = value;
                if (value === null || value === undefined) {
                  displayValue = '-';
                } else if (typeof value === 'object') {
                  try {
                    displayValue = JSON.stringify(value);
                  } catch (e) {
                    displayValue = '[Complex Object]';
                  }
                }
                
                detailedContent += '\
                  <div style="margin-bottom: 6px;">\
                    <strong>' + displayKey + ':</strong> ' + displayValue + '\
                  </div>\
                ';
              });
              
              detailedContent += '\
                  </div>\
                </div>\
              ';
              
              // Hide the items container and show the detailed view
              itemsContainer.style.display = 'none';
              detailedView.innerHTML = detailedContent;
              detailedView.style.display = 'block';
              
              // Add event listener for back button
              document.getElementById('back-to-list').addEventListener('click', () => {
                detailedView.style.display = 'none';
                itemsContainer.style.display = 'block';
              });
            });
          });
        })();
      </script>
    `;
    
    return content;
  };
  
  const addMarkerToMap = (item: MapData, coordinates: any) => {
    if (!map.current) return;
    
    console.log('Adding marker for item:', item.id, 'with coordinates:', coordinates);
    
    // Determine marker position based on geometry type or format
    let position: [number, number];
    
    if (coordinates.type === 'Point' && Array.isArray(coordinates.coordinates)) {
      // GeoJSON Point format
      position = [coordinates.coordinates[0], coordinates.coordinates[1]];
    } else if (coordinates.type === 'MultiLineString' && Array.isArray(coordinates.coordinates)) {
      // For MultiLineString, use the first point of the first line
      if (coordinates.coordinates.length > 0 && 
          Array.isArray(coordinates.coordinates[0]) && 
          coordinates.coordinates[0].length > 0 && 
          Array.isArray(coordinates.coordinates[0][0]) && 
          coordinates.coordinates[0][0].length >= 2) {
        position = [coordinates.coordinates[0][0][0], coordinates.coordinates[0][0][1]];
      } else {
        console.error('Invalid MultiLineString format:', coordinates);
        return;
      }
    } else if (Array.isArray(coordinates) && coordinates.length === 2) {
      // Simple array format [lng, lat]
      position = [coordinates[0], coordinates[1]];
    } else if (coordinates.lng !== undefined && coordinates.lat !== undefined) {
      // Object with lng/lat properties
      position = [coordinates.lng, coordinates.lat];
    } else if (coordinates.longitude !== undefined && coordinates.latitude !== undefined) {
      // Object with longitude/latitude properties
      position = [coordinates.longitude, coordinates.latitude];
    } else {
      console.error('Unsupported coordinate format:', coordinates);
      return;
    }
    
    // Get color based on dataset and event type
    const color = getDatasetColor(
      item.datasource_tablename,
      item.event_type,
      item.priority_level
    );
    
    // Add this point to the cluster source instead of creating a separate marker
    const source = map.current.getSource(CLUSTER_SOURCE_ID) as mapboxgl.GeoJSONSource;
    if (!source) {
      console.error('Cluster source not found');
      return;
    }
    
    // Get the current data from the source
    const currentData = (source as any)._data as GeoJSON.FeatureCollection;
    if (!currentData || !currentData.features) {
      console.error('Invalid source data structure');
      return;
    }
    
    // Check if there's already a feature at this exact position
    const positionKey = `${position[0]},${position[1]}`;
    const existingFeatureIndex = currentData.features.findIndex(feature => {
      const coords = feature.geometry.type === 'Point' ? feature.geometry.coordinates : null;
      return coords && `${coords[0]},${coords[1]}` === positionKey;
    });
    
    if (existingFeatureIndex >= 0) {
      // We found an existing feature at this position
      const existingFeature = currentData.features[existingFeatureIndex];
      
      // Check if the existing feature already has multiple items
      if (existingFeature.properties && existingFeature.properties.items && Array.isArray(existingFeature.properties.items)) {
        // Add this item to the existing array
        existingFeature.properties.items.push(item);
        // Update the count
        existingFeature.properties.count = existingFeature.properties.items.length;
        // Update the color to indicate multiple items
        existingFeature.properties.color = '#FF5722'; // Orange color for multi-item markers
        // Update the popup content to show all items
        existingFeature.properties.popupContent = createMultiItemPopupContent(existingFeature.properties.items);
      } else {
        // Convert the single item to a multi-item feature
        const originalItem = { ...existingFeature.properties };
        // Remove properties that shouldn't be duplicated
        delete originalItem.color;
        delete originalItem.popupContent;
        delete originalItem.count;
        delete originalItem.items;
        
        // Create an array with both items
        const items = [originalItem, item];
        
        // Update the feature properties
        existingFeature.properties.items = items;
        existingFeature.properties.count = items.length;
        existingFeature.properties.color = '#FF5722'; // Orange color for multi-item markers
        existingFeature.properties.popupContent = createMultiItemPopupContent(items);
      }
    } else {
      // No existing feature at this position, create a new one
      const newFeature: GeoJSON.Feature = {
        type: 'Feature',
        geometry: {
          type: 'Point',
          coordinates: position
        },
        properties: {
          // Include all item properties first
          ...item,
          // Then override or add specific properties we need for display
          color: color,
          popupContent: createPopupContent(item)
        }
      };
      
      // Add the new feature to the collection
      currentData.features.push(newFeature);
    }
    
    // Update the source data
    source.setData(currentData);
    
    // Add this dataset to the visible datasets for the legend
    setVisibleDatasets(prev => {
      const newSet = new Set(prev);
      newSet.add(item.datasource_tablename);
      return newSet;
    });
  };
  
  // Function to add a road line to the map
  const addRoadToMap = (name: string, coordinates: number[][][]) => {
    if (!map.current) return;
    
    console.log('Adding road line for:', name, 'with coordinates:', coordinates);
    
    // Create unique IDs for this road's source and layer
    const sourceId = `road-source-${roadSourceCounter}`;
    const layerId = `road-layer-${roadSourceCounter}`;
    roadSourceCounter++;
    
    // Create a GeoJSON source for the road
    const source: mapboxgl.AnySourceData = {
      type: 'geojson',
      data: {
        type: 'Feature',
        properties: {
          name: name
        },
        geometry: {
          type: 'MultiLineString',
          coordinates: coordinates
        }
      }
    };
    
    // Add the source to the map
    map.current.addSource(sourceId, source);
    
    // Add a line layer to display the road
    map.current.addLayer({
      id: layerId,
      type: 'line',
      source: sourceId,
      layout: {
        'line-join': 'round',
        'line-cap': 'round'
      },
      paint: {
        'line-color': '#FF6B6B', // Distinct color for roads
        'line-width': 5,
        'line-opacity': 0.8
      }
    });
    
    // Store reference to the layer and source for later cleanup
    roadLayersRef.current.push({sourceId, layerId});
    
    // Add a popup when clicking on the road
    map.current.on('click', layerId, (e) => {
      if (e.features && e.features.length > 0) {
        const coordinates = e.lngLat;
        
        new mapboxgl.Popup()
          .setLngLat(coordinates)
          .setHTML(`
            <div class="p-3">
              <h3 class="text-lg font-bold mb-2">${name}</h3>
              <div class="text-sm">
                <p>Road</p>
              </div>
            </div>
          `)
          .addTo(map.current!);
      }
    });
    
    // Change cursor to pointer when hovering over the road
    map.current.on('mouseenter', layerId, () => {
      if (map.current) map.current.getCanvas().style.cursor = 'pointer';
    });
    
    map.current.on('mouseleave', layerId, () => {
      if (map.current) map.current.getCanvas().style.cursor = '';
    });
    
    // Fit the map to the road's coordinates
    const bounds = new mapboxgl.LngLatBounds();
    
    // Add all coordinates to the bounds
    coordinates.forEach(lineString => {
      lineString.forEach(point => {
        bounds.extend([point[0], point[1]]);
      });
    });
    
    // Fit the map to the bounds with padding
    map.current.fitBounds(bounds, {
      padding: 50,
      maxZoom: 15
    });
  };
  
  // Function to add a POI marker to the map
  const addPOIMarkerToMap = (name: string, coordinates: {lat: number, lng: number}, radiusMiles?: number) => {
    if (!map.current) return;
    
    console.log('Adding POI marker for:', name, 'at coordinates:', coordinates, 'with radius:', radiusMiles);
    
    // Create marker element with special styling for POIs
    const markerEl = document.createElement('div');
    markerEl.className = 'poi-marker';
    markerEl.setAttribute('data-poi-name', name); // Store the POI name directly on the element
    markerEl.setAttribute('data-poi-type', 'selection'); // Mark as selection marker
    markerEl.style.backgroundColor = '#4A6FE3'; // Distinct blue color for POIs
    markerEl.style.width = '28px';
    markerEl.style.height = '28px';
    markerEl.style.borderRadius = '50%';
    markerEl.style.display = 'flex';
    markerEl.style.alignItems = 'center';
    markerEl.style.justifyContent = 'center';
    markerEl.style.border = '3px solid white';
    markerEl.style.boxShadow = '0 3px 6px rgba(0,0,0,0.4)';
    
    // Add icon or label for POI
    const iconEl = document.createElement('div');
    iconEl.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>';
    iconEl.style.color = 'white';
    markerEl.appendChild(iconEl);
    
    // Create popup with POI information
    const popup = new mapboxgl.Popup({
      closeButton: true,
      closeOnClick: true,
      maxWidth: '300px'
    }).setHTML(`
      <div class="p-3">
        <h3 class="text-lg font-bold mb-2">${name}</h3>
        <div class="text-sm">
          <p>Point of Interest</p>
          <p>Coordinates: ${coordinates.lat.toFixed(6)}, ${coordinates.lng.toFixed(6)}</p>
        </div>
      </div>
    `);
    
    // Add marker to map
    const marker = new mapboxgl.Marker(markerEl)
      .setLngLat([coordinates.lng, coordinates.lat])
      .setPopup(popup);
    
    if (map.current) {
      marker.addTo(map.current);
      
      // Store reference for later cleanup
      poiMarkersRef.current.push(marker);
      
      // Fly to the marker location
      map.current.flyTo({
        center: [coordinates.lng, coordinates.lat],
        zoom: 14
      });
      
      // If radius is provided, add a circle around the POI
      if (radiusMiles && radiusMiles > 0) {
        // Create a point using Turf.js
        const point = turf.point([coordinates.lng, coordinates.lat]);
        
        // Create a circle with the specified radius in miles
        // Note: turf.buffer takes radius in kilometers, so convert miles to km
        const radiusKm = radiusMiles * 1.60934;
        const circle = turf.buffer(point, radiusKm, { units: 'kilometers' });
        
        // Create unique IDs for this circle's source and layer
        const sourceId = `poi-circle-source-${poiCircleCounter}`;
        const layerId = `poi-circle-layer-${poiCircleCounter}`;
        poiCircleCounter++;
        
        // Add the circle as a source
        map.current.addSource(sourceId, {
          type: 'geojson',
          data: circle
        });
        
        // Add a fill layer for the circle
        map.current.addLayer({
          id: layerId,
          type: 'fill',
          source: sourceId,
          paint: {
            'fill-color': '#4A6FE3',
            'fill-opacity': 0.2,
            'fill-outline-color': '#4A6FE3'
          }
        });
        
        // Store reference to the layer and source for later cleanup
        poiCircleLayersRef.current.push({sourceId, layerId, poiName: name});
        
        // Add a popup when hovering over the circle
        map.current.on('mouseenter', layerId, () => {
          if (map.current) {
            map.current.getCanvas().style.cursor = 'pointer';
          }
        });
        
        map.current.on('mouseleave', layerId, () => {
          if (map.current) {
            map.current.getCanvas().style.cursor = '';
          }
        });
      }
    }
  };
  
  // Color-blind friendly color scheme
  // Based on ColorBrewer and Okabe-Ito color schemes which are designed to be distinguishable by those with color vision deficiencies
  const colorBlindFriendlyColors: Record<string, string> = {
    // Main colors for datasets
    'traffic_events': '#0072B2',       // Blue
    'lane_blockage_info': '#E69F00',   // Orange
    'rest_area_info': '#009E73',       // Green
    'dynamic_message_sign_info': '#CC79A7', // Pink
    'traffic_parking_info': '#56B4E9',  // Light blue
    'travel_time_system_info': '#D55E00', // Red-orange
    'variable_speed_limit_sign_info': '#F0E442', // Yellow
    'social_events': '#CC6677',       // Rose
    'weather_info': '#882255',        // Purple
    'default': '#999999'              // Gray
  };
  
  // Function to get dataset color
  const getDatasetColor = (tableName: string, eventType?: string, priorityLevel?: number): string => {
    // If we have a color defined for this table, use it
    if (colorBlindFriendlyColors[tableName]) {
      return colorBlindFriendlyColors[tableName];
    }
    
    // Special case for traffic events - color by event type if available
    if (tableName === 'traffic_events' && eventType) {
      const eventColors: Record<string, string> = {
        'ACCIDENT': '#D55E00',         // Red-orange
        'VEHICLE FIRE': '#CC79A7',     // Pink
        'CONSTRUCTION': '#E69F00',     // Orange
        'CONGESTION': '#56B4E9',       // Light blue
        'SPECIAL EVENT': '#009E73',    // Green
        'WEATHER': '#0072B2',          // Blue
        'default': colorBlindFriendlyColors.traffic_events
      };
      
      const normalizedEventType = eventType.toUpperCase();
      return eventColors[normalizedEventType] || eventColors.default;
    }
    
    // Fall back to default color for dataset
    return colorBlindFriendlyColors.default;
  };
  
  // Track which datasets are currently visible on the map for the legend
  const [visibleDatasets, setVisibleDatasets] = useState<Set<string>>(new Set());
  
  // Track which datasets are selected (regardless of visibility)
  const [selectedDatasets, setSelectedDatasets] = useState<Set<string>>(new Set());
  
  // Function to get marker icon based on dataset type
  const getMarkerIcon = (item: MapData): string => {
    const { datasource_tablename, event_type } = item;
    
    // Custom icons for each dataset type
    switch (datasource_tablename) {
      case 'traffic_events':
        // Different icons based on event type
        if (event_type) {
          const normalizedEventType = event_type.toUpperCase();
          
          switch (normalizedEventType) {
            case 'ACCIDENT':
              return '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><path d="M12 9v4"></path><path d="M12 17h.01"></path></svg>';
            case 'VEHICLE FIRE':
              return '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.153.433-2.294 1-3a2.5 2.5 0 0 0 2.5 2.5z"></path></svg>';
            case 'CONSTRUCTION':
              return '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="6" width="20" height="8" rx="1"></rect><path d="M17 14v7"></path><path d="M7 14v7"></path><path d="M17 3v3"></path><path d="M7 3v3"></path><path d="M10 14 2.3 6.3"></path><path d="m14 6 7.7 7.7"></path><path d="m8 6 8 8"></path></svg>';
            case 'CONGESTION':
              return '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"></path><path d="M12 5v14"></path></svg>';
            case 'SPECIAL EVENT':
              return '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 8a2 2 0 0 0 2-2H6a2 2 0 0 0 2 2Z"></path><path d="M2 8h20"></path><path d="M20 8v10a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V8Z"></path><path d="M8 12h8"></path><path d="M8 16h4"></path></svg>';
            case 'WEATHER':
              return '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 16.2A4.5 4.5 0 0 0 17.5 8h-1.8A7 7 0 1 0 4 14.9"></path><path d="M16 14v6"></path><path d="M8 14v6"></path><path d="M12 16v6"></path></svg>';
            default:
              return '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>';
          }
        }
        return '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>';
        
      case 'lane_blockage_info':
        return '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1-2.5-2.5Z"></path><path d="M8 21V5"></path><path d="M12 21V5"></path><path d="M16 21V5"></path></svg>';
        
      case 'rest_area_info':
        return '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 9h18v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V9Z"></path><path d="M3 9V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v4"></path><path d="M12 12h.01"></path></svg>';
        
      case 'dynamic_message_sign_info':
        return '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="20" height="14" x="2" y="5" rx="2"></rect><line x1="2" x2="22" y1="10" y2="10"></line></svg>';
        
      case 'traffic_parking_info':
        return '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect width="18" height="18" x="3" y="3" rx="2"></rect><path d="M9 17V7h4a3 3 0 0 1 0 6H9"></path></svg>';
        
      case 'travel_time_system_info':
        return '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>';
        
      case 'variable_speed_limit_sign_info':
        return '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m12 2 10 10-10 10-10-10Z"></path></svg>';
        
      case 'social_events':
        return '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 20V8.5a4.5 4.5 0 0 0-9 0v11.5"></path><path d="M2 19v-4a6 6 0 0 1 6-6h8a6 6 0 0 1 6 6v4"></path><path d="m9 8 3-3 3 3"></path></svg>';
        
      case 'weather_info':
        return '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 16.2A4.5 4.5 0 0 0 17.5 8h-1.8A7 7 0 1 0 4 14.9"></path><path d="M12 16v6"></path></svg>';
        
  };
  
  // Check if any keywords match the dataset name
  for (const [keyword, icon] of Object.entries(iconMappings)) {
    if (datasource_tablename.toLowerCase().includes(keyword)) {
      datasetIcon = icon;
      break;
    }
  }
  
  // Start with styled container and header - without the extra close button
  let content = `
    <div class="popup-container" style="font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; max-width: 320px; max-height: 400px; overflow-y: auto;">
      <div style="display: flex; align-items: center; border-bottom: 2px solid #e5e7eb; padding-bottom: 8px; margin-bottom: 12px;">
        <div style="font-size: 24px; margin-right: 8px;">${datasetIcon}</div>
        <h2 style="margin: 0; font-size: 20px; font-weight: 600; color: #1f2937;">${datasetDisplayName}</h2>
      </div>
  `;
  
  // We no longer need dataset-specific handling - everything is generic
  
  // Define properties to exclude from display
  // This is a generic list that works for all datasets
  const excludedProps = [
    'id', 'datasource_metadata_id', 'datasource_tablename', 
    'readable_coordinates', 'coordinates', 'geometry', 
    'geojson', 'position', 'lat', 'lng', 'latitude', 'longitude'
  ];
  
  // Group properties into categories for better organization
  // These are generic categories that work for any dataset
  const timeRelatedKeywords = ['date', 'time', 'timestamp', 'start', 'end', 'created', 'updated', 'retrieval', 'period'];
  const locationKeywords = ['location', 'city', 'county', 'state', 'address', 'venue', 'category', 'route', 'mile', 'marker', 'road', 'highway', 'street', 'intersection'];
  const statusKeywords = ['status', 'condition', 'state', 'type', 'classification', 'segment', 'genre', 'subgenre', 'level', 'severity', 'event_name'];
  
  // Generic function to render a property section
  const renderPropertySection = (properties: string[], title: string, isLast = false) => {
    if (properties.length === 0) return '';
    
    let sectionContent = `<h3 style="font-size: 16px; margin: 12px 0 8px 0; color: #374151;">${title}</h3>
      <div style="background-color: #f3f4f6; border-radius: 6px; padding: 10px;${!isLast ? ' margin-bottom: 12px;' : ''}">`;
    
    properties.forEach(key => {
      // Format the value based on its type
      let formattedValue = item[key];
      
      if (typeof formattedValue === 'object') {
        try {
          formattedValue = JSON.stringify(formattedValue);
        } catch (e) {
          formattedValue = '[Complex Object]';
        }
      }
      
      // Format the key for display (convert snake_case to Title Case)
      const displayKey = key
        .split('_')
        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
        .join(' ');
      
      sectionContent += `
        <div style="display: flex; margin-bottom: 6px;">
          <div style="width: 140px; font-weight: 600; color: #4b5563;">${displayKey}:</div>
          <div>${formattedValue}</div>
        </div>
      `;
    });
    
    sectionContent += `</div>`;
    return sectionContent;
  };
  
  // Filter properties by category
  const getPropertiesByCategory = (categoryKeywords: string[]) => {
    return Object.keys(item).filter(key => 
      !excludedProps.includes(key) && 
      categoryKeywords.some((prop: string) => key.toLowerCase().includes(prop)) &&
      item[key] !== null && 
      item[key] !== undefined
    );
  };
  
  // Status and type properties
  const statusProps = getPropertiesByCategory(statusKeywords);
  content += renderPropertySection(statusProps, 'Status & Classification');
  
  // Time-related properties
  const timeProps = getPropertiesByCategory(timeRelatedKeywords);
  content += renderPropertySection(timeProps, 'Time Information');
  
  // Location-related properties
  const locProps = getPropertiesByCategory(locationKeywords);
  content += renderPropertySection(locProps, 'Location Details');
  
  // Get remaining properties that don't fit in other categories
  const detailProps = Object.keys(item).filter(key => 
    !excludedProps.includes(key) && 
    !timeRelatedKeywords.some((prop: string) => key.toLowerCase().includes(prop)) &&
    !locationKeywords.some((prop: string) => key.toLowerCase().includes(prop)) &&
    !statusKeywords.some((prop: string) => key.toLowerCase().includes(prop)) &&
    item[key] !== null && 
    item[key] !== undefined
  );
  
  // Add remaining properties if any
  if (detailProps.length > 0) {
    content += renderPropertySection(detailProps, 'Additional Details', true);
  }
  
  // Close the container
  content += `
    </div>
          <h2 style="margin: 0; font-size: 20px; font-weight: 600; color: #1f2937;">${items.length} Items at this Location</h2>
        </div>
      </div>
      
      <div class="pagination-container" style="margin-bottom: 12px;">
        <div style="display: flex; justify-content: space-between; align-items: center;">
          <button id="prev-item" class="pagination-button" style="background-color: #e5e7eb; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; display: flex; align-items: center;" disabled>
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15 18-6-6 6-6"/></svg>
            Previous
          </button>
          <span id="pagination-info" style="font-size: 14px;">Item 1 of ${items.length}</span>
          <button id="next-item" class="pagination-button" style="background-color: #e5e7eb; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; display: flex; align-items: center;">
            Next
            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m9 18 6-6-6-6"/></svg>
          </button>
        </div>
      </div>
      
      <div id="items-container">
  `;
  
  // Add each item's content in a separate div that will be shown/hidden via JavaScript
  items.forEach((item, index) => {
    const isVisible = index === 0 ? 'block' : 'none';
    content += `<div id="item-${index}" class="item-content" style="display: ${isVisible};">`;
    
    // Get dataset display name
    const datasetDisplayName = item.datasource_tablename
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
    
    content += `
      <div style="background-color: #f3f4f6; border-radius: 6px; padding: 10px; margin-bottom: 12px;">
        <div style="font-weight: 600; color: #4b5563; margin-bottom: 6px;">${datasetDisplayName}</div>
    `;
    
    // Add a subset of important properties for the summary view
    const importantProps = ['name', 'title', 'description', 'type', 'status', 'event_type', 'severity'];
    
    // Find the first available important property
    let foundImportantProp = false;
    for (const prop of importantProps) {
      if (item[prop] !== undefined && item[prop] !== null) {
        const displayKey = prop
          .split('_')
          .map(word => word.charAt(0).toUpperCase() + word.slice(1))
          .join(' ');
        
        content += `<div><strong>${displayKey}:</strong> ${item[prop]}</div>`;
        foundImportantProp = true;
        break;
      newVisibility[tableName] = !prev[tableName];
      return newVisibility;
    });
    
    // Update visibleDatasets based on the new visibility state
    setVisibleDatasets(prev => {
      const newVisibleDatasets = new Set(prev);
      if (visibleLayers[tableName]) {
        // If it was visible and now being hidden, remove from visible datasets
        newVisibleDatasets.delete(tableName);
      } else {
        // If it was hidden and now being shown, add to visible datasets
        newVisibleDatasets.add(tableName);
      }
      return newVisibleDatasets;
    });
  };
  
  return (
    <div className="h-full w-full relative">
      <div ref={mapContainer} className="h-full w-full" />
      
      {/* Dynamic Legend */}
      <Card className={`absolute right-4 top-4 p-4 w-64 bg-white/95 shadow-lg transition-all ${showLegend ? 'opacity-100' : 'opacity-0 pointer-events-none'}`}>
        <div className="flex justify-between items-center mb-2">
          <h3 className="font-semibold">Map Legend</h3>
          <Button variant="ghost" size="sm" className="h-6 w-6 p-0" onClick={() => setShowLegend(false)}>
            <ChevronUp className="h-4 w-4" />
          </Button>
        </div>
        
        <div className="space-y-4">
          <h4 className="text-sm font-medium mb-2">Datasets</h4>
          
          {/* Show datasets that the user has selected, regardless of visibility */}
          <div className="grid grid-cols-1 gap-2">
            {Array.from(selectedDatasets).map(tableName => {
              // Get the color for this dataset
              const color = colorBlindFriendlyColors[tableName as keyof typeof colorBlindFriendlyColors] || colorBlindFriendlyColors.default;
              
              // Get a display name for the dataset
              const displayName = (() => {
                switch(tableName) {
                  case 'traffic_events': return 'Traffic Events';
                  case 'lane_blockage_info': return 'Lane Blockages';
                  case 'rest_area_info': return 'Rest Areas';
                  case 'dynamic_message_sign_info': return 'Dynamic Message Signs';
                  case 'traffic_parking_info': return 'Truck Parking';
                  case 'travel_time_system_info': return 'Travel Time Signs';
                  case 'variable_speed_limit_sign_info': return 'Variable Speed Limit Signs';
                  case 'social_events': return 'Social Events';
                  case 'weather_info': return 'Weather Information';
                  default: return tableName;
                }
              })();
              
              return (
                <div key={tableName} className="flex items-center justify-between">
                  <div className="flex items-center space-x-2">
                    <div 
                      className="w-5 h-5 rounded-full flex items-center justify-center"
                      style={{ backgroundColor: color }}
                    >
                      <div 
                        className="text-white" 
                        dangerouslySetInnerHTML={{ 
                          __html: getMarkerIcon({ datasource_tablename: tableName } as MapData) 
                        }} 
                      />
                    </div>
                    <span className="text-sm">{displayName}</span>
                  </div>
                  <Button 
                    variant="ghost" 
                    size="sm" 
                    className="h-6 w-6 p-0 text-gray-500 hover:text-gray-900"
                    onClick={() => toggleLayerVisibility(tableName)}
                  >
                    {visibleLayers[tableName] ? (
                      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"></path>
                        <circle cx="12" cy="12" r="3"></circle>
                      </svg>
                    ) : (
                      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                        <path d="M9.88 9.88a3 3 0 1 0 4.24 4.24"></path>
                        <path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68"></path>
                        <path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61"></path>
                        <line x1="2" x2="22" y1="2" y2="22"></line>
                      </svg>
                    )}
                  </Button>
                </div>
              );
            })}
          </div>
        </div>
      </Card>
      
      {/* Toggle button for legend when hidden */}
      {!showLegend && (
        <Button 
          variant="secondary" 
          size="sm" 
          className="absolute right-4 top-4 bg-white/95 shadow-lg"
          onClick={() => setShowLegend(true)}
        >
          <Info className="h-4 w-4 mr-1" />
          Legend
        </Button>
      )}
    </div>
  );
}
